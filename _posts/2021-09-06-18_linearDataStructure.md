---
title: "[알고리즘]기초자료구조 - 3.선형자료구조"
date: 2021-09-06 09:00:00 +0900
categories: [Algorithm]
tags: [algorithm, data-structure]
---
# 선형자료구조

## 도입
일렬로 늘어선 같은 종류의 자료 여러개를 저장하기 위해 가장 보편적으로 배열을 사용한다. 선형자료구조는 배열과 비슷하지만 배열로 구현하면 비효율적이거나 불가능한 작업들을 효율적으로 할 수 있도록 한다. 

<br>

# 동적 배열
배열의 여러 제한사항 중 하나는 그 크기가 선언할 때 이미 정해진다는 것이다. 때문에 크기 이상의 자료들을 저장할 수 없고 이 문제를 해결하기 위해 동적 배열이 고안되었다.

### 동적 배열과 배열이 갖는 특성
- 원소들은 메모리의 연속된 위치에 저장된다.  
    (캐싱은 기본적으로 접근했던 데이터들, 그와 인접한 데이터들을 중심으로 이루어지기 때문에 이러한 구조는 캐시의 효율성과 직결된다.)  

- 주어진 위치의 원소를 반환하거나 변경하는 동작을 *O(1)*에 할 수 있다.

### 동적 배열이 추가로 갖는 특성
- 배열의 크기를 변경하는 resize()연산이 가능하다. 배열의 크기에 비례하는 시간이 걸린다.  

- 주어진 원소를 배열의 맨끝에 추가함으로써 크기를 1 늘리는 append()연산을 지원한다. 이때 이 동작에 상수 시간이 걸린다.

<br>

## 동적 배열의 재할당 전략
resize()연산을 할 때는 새 배열을 동적으로 할당해 기존 원소를 복사한 뒤 바꿔치기 한다. 이는 쉽게 *O(N)*에 구현될 수 있다.

append()가 호출될 때 상수 시간에 동작할 수 있도록 구현하려면 동적 배열을 할당 받을 때 여유분을 미리 할당 받아야 한다. 해당 여유분도 모두 사용해 재할당을 받아야 한다.

    이때 재할당받는 크기를 고정되게 사용하게 되면 append()는 상수시간에 구현할 수 없게 된다. 예를 들어 한 번에 늘리는 배열의 용량 M = 100 이라고 하고 append()를 1만번 수행한다고 하면 재할당은 총 99번 일어나게 된다. 그러면 수행하게 되는 복사의 전체 수는 100 + 200 + 300 + ... + 9900 = 495,000이 되게 된다.

이러한 상황을 피하기 위해 재할당을 받을 때는 현재 가진 원소에 비례해서 할당받을 여유분을 정하게 된다. 예를 들어 재할당마다 2배의 여유분을 확보한다면 아래와 같이 *O(1)*에 구현할 수 있다.

![image](/assets/img/posts/20210906.jpg)

<br>

## 표준 라이브러리의 동적 배열
현재 사용되는 언어 대부분이 동적 배열을 표준 라이브러리에서 제공한다.
 - C++ :  vector
 - JAVA, C# : ArrayList

<br>

# 연결 리스트 