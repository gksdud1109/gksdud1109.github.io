---
title: "[프론트 기초] React.useState() 수정,삭제,조건부 렌더링"
excerpt: "리액트 & 테일윈드#5"

categories:
  - front

date: 2025-08-25
last_modified_at: 2025-08-25
---

## React.useState()

```js
console.clear();

import React from "https://esm.sh/react@rc?dev";
import ReactDOMClient from "https://esm.sh/react-dom@rc/client/?dev";

const rootElement = ReactDOMClient.createRoot(document.getElementById("root"));

function App() {
  let id = 1;
  const [number, setNumber] = React.useState(0); // 이거 바뀌면 다시 그리라고 하고 싶다.

  return (
    <>
      <button
        className="p-2 border-2 rounded"
        onClick={() => {
          setNumber(number + 1);
          console.log(number);
        }}
      >
        버튼
      </button>
      <div>{number}</div>
    </>
  );
}

rootElement.render(<App />);
```

- React의 useState는 컴포넌트 안에서 값(상태)을 기억하고, 그 값이 바뀌면 다시 렌더링을 트리거하는 훅(Hook)이다.

```js
const [state, setState] = React.useState(initialValue);
```

- state: 현재 상태 값(예제 코드에서는 number)
- setState: 상태를 바꿀 때 호출하는 함수(여기서는 setNumber)
- initialValue: 초기값 (여기서는 0)
- onClick 이벤트가 발생시에 React가 number를 쳐다보고 있다가 정의된 setNumber함수 동작을 실행하고 다시 렌더링해서 새로운 number값을 반영한다.

## 삭제 동작 구현

```js
console.clear();

import React from "https://esm.sh/react@rc?dev";
import ReactDOMClient from "https://esm.sh/react-dom@rc/client/?dev";

const rootElement = ReactDOMClient.createRoot(document.getElementById("root"));

function Link({ text, href }) {
  return (
    <a
      className="text-red-500 underline hover:text-red-300"
      href={href}
      target="_blank"
    >
      {text}
    </a>
  );
}

function App() {
  const [links, setLinks] = React.useState([
    {
      text: "네이버",
      href: "https://www.naver.com",
    },
    {
      text: "다음",
      href: "https://www.daum.net",
    },
    {
      text: "구글",
      href: "https://www.google.com",
    },
    {
      text: "야후",
      href: "https://www.yahoo.com",
    },
  ]);

  function deleteItem(index) {
    setLinks(links.filter((link, _index) => _index != index));
  }

  return (
    <>
      <ul>
        {links.map((link, index) => (
          <li key={index} className="p-2">
            <Link text={link.text} href={link.href} />
            <button
              className="ml-2 cursor-pointer"
              onClick={() => {
                deleteItem(index);
              }}
            >
              X
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}

rootElement.render(<App />);
```

- App()안에 정의된 useState(초기값) -> 네이버, 다음, 구글, 야후 4개 링크
- links에 저장된 초기값으로 Link({text, href}) 함수로 페이지에 뿌려줌
- 이때 각 \<li> 태그에 map()을 할때 주어지는 index를 key값으로 주어서 헷갈리지 않게한다.
- link를 렌더해줄 떄 옆에 button을 만들어주었고 여기서 onClick시에 deleteItem()을 호출한다.

- deleteItem에서는 setLinks()(<- 상태를 바꿀떄 호출하는 함수)에 filter를 주어서 해당 인덱스만 지운 links를 다시 렌더하도록 한다.

## 수정 기능 추가

```js
// React import와 DOM객체 초기화 생략

function Link({ text, href }) {
  return (
    <a
      className="text-red-500 underline hover:text-red-300"
      href={href}
      target="_blank"
    >
      {text}
    </a>
  );
}

function LinkItem({ link, index, deleteItem }) {
  const [isModifyingMode, setIsModifyingMode] = React.useState(false);

  return (
    <>
      <Link text={link.text} href={link.href} />
      <button
        className="ml-2 p-2 border-2 rounded cursor-pointer"
        onClick={() => {
          deleteItem(index);
        }}
      >
        삭제
      </button>
      <button
        className="ml-2 p-2 border-2 rounded cursor-pointer"
        onClick={() => {
          setIsModifyingMode(!isModifyingMode);
        }}
      >
        수정
      </button>
      {isModifyingMode && (
        <div>
          <input
            type="text"
            placeholder="새 이름을 입력해주세요"
            className="border-2 p-2 rounded"
          />
        </div>
      )}
    </>
  );
}

function App() {
  const [links, setLinks] = React.useState([
    {
      text: "네이버",
      href: "https://www.naver.com",
    },
    {
      text: "다음",
      href: "https://www.daum.net",
    },
    {
      text: "구글",
      href: "https://www.google.com",
    },
    {
      text: "야후",
      href: "https://www.yahoo.com",
    },
  ]);

  function deleteItem(index) {
    setLinks(links.filter((link, _index) => _index != index));
  }

  return (
    <>
      <ul>
        {links.map((link, index) => (
          <li key={index} className="p-2">
            <LinkItem link={link} index={index} deleteItem={deleteItem} />
          </li>
        ))}
      </ul>
    </>
  );
}

rootElement.render(<App />);
```

- isModifyingMode -> 현재 이 LinkItem이 수정 모드인지 여부를 기억하는 상태, false로 초기값 설정 -> 기본 상태에서는 수정창이 보이지 않음

```js
const [isModifyingMode, setIsModifyingMode] = React.useState(false);
```

- \<button>에 수정 버튼 추가 -> onClick시에 setIsModifyingMode()를 호출
- set함수는 false<->true로 클릭할 떄마다 바뀌고 렌더 -> 토글 식으로 전환되는거임

### 조건부 렌더링

```jsx
{
  isModifyingMode && (
    <div>
      <input
        type="text"
        placeholder="새 이름을 입력해주세요"
        className="border-2 p-2 rounded"
      />
    </div>
  );
}
```

- JSX에서 {조건 && <컴포넌트>}는 조건이 true일 때만 컴포넌트 출력하는 패턴
- isModifyingMode === true → \<div>\<input/>\</div> 표시
- isModifyingMode === false → 아무것도 출력되지 않음

### JSX는 사실 JavaScript

> JSX는 Babel을 통해 JS로 바뀜
> 아래 코드는 JS코드로 변환되서 React가 해석함.

```jsx
{
  조건 && <div>Hello</div>;
}
```

> JS에서의 &&연산자 -> 논리곱 연산자이지만, 결과를 true/false로만 돌려주지 않음</br>
>
> - 앞쪽 값이 truthy면 뒤쪽값을 반환
> - 앞쪽 값이 falsy면 그 값을 그대로 반환

```js
true && "A"; // "A"
false && "A"; // false
0 && "A"; // 0
123 && "A"; // "A"
```

### React는 렌더링 할때

- null, false, undefined -> falsy값은 렌더링 안함
- 문자열, 숫자 -> 그대로 출력
- react엘리먼트(\<div> ... \</div>) -> 그려줌(렌더링)

### 그래서 조건부 렌더링은

```jsx
{조건 && <컴포넌트>}
```

- 조건이 true -> JS연산 결과는 \<컴포넌트> -> react가 렌더링
- 조건이 false -> JS연산 결과는 false -> 렌더링 안함 -> 아무것도 안보임

- 그래서 조건부 렌더링처럼 동작하는 거다!

> 💡 왜 이렇게까지하나면,,, </br>
> if문을 JSX안에 직접 쓸 수 없어서, 표현식으로 처리하려고 이 패턴을 씀..

<hr>

[![image.jpg](https://i.postimg.cc/rFSm1DRg/image.jpg)](https://postimg.cc/QHdhsxbW)
