---
title: "[프론트 기초]뚜두리스트 삭제기능 구현"
date: 2025-09-08 09:00:00 +0900
categories: [React]
tags: [react, javascript, frontend]
---
## 뚜두리스트 삭제기능 구현하기

### 시작코드

```jsx
console.clear();

import React, { useState } from "https://esm.sh/react@rc?dev";
import ReactDOMClient from "https://esm.sh/react-dom@rc/client/?dev";

const rootElement = ReactDOMClient.createRoot(document.getElementById("root"));

function App() {
  const [todos, setTodos] = useState(["책 읽기", "CS 공부", "알고리즘 풀기"]);

  const onSubmitHandle = (e) => {
    e.preventDefault();

    const form = e.target;
    console.log(form.query.value);

    setTodos([form.query.value, ...todos]);

    form.query.value = "";
    form.query.focus();
  };

  return (
    <>
      <form target="_blank" onSubmit={onSubmitHandle}>
        <input
          name="query"
          type="text"
          placeholder="할 일을 등록해주세요."
          className="p-2 border-2 rounded"
        />
        <input
          type="submit"
          value="등록"
          className="p-2 border-2 rounded ml-2"
        />
      </form>
      <ul>
        {todos.map((_todo, _index) => (
          <li key={_index} className="p-2">
            - {_todo}
          </li>
        ))}
      </ul>
    </>
  );
}

rootElement.render(<App />);
```

### 삭제버튼 -> 누르면 아이템 삭제

```jsx
function App() {
  const [todos, setTodos] = useState(["책 읽기", "CS 공부", "알고리즘 풀기"]);

  const onSubmitHandle = (e) => {
    e.preventDefault();

    const form = e.target;
    console.log(form.query.value);

    setTodos([form.query.value, ...todos]);
    form.query.value = "";
    form.query.focus();
  };

  return (
    <>
      <form target="_blank" onSubmit={onSubmitHandle}>
        <input
          name="query"
          type="text"
          placeholder="할 일을 등록해주세요."
          className="p-2 border-2 rounded"
        />
        <input
          type="submit"
          value="등록"
          className="p-2 border-2 rounded ml-2"
        />
      </form>
      <ul>
        {todos.map((_todo, _index) => (
          <li key={_index} className="p-2">
            <span>- {_todo}</span>
            <button
              className="p-2 border-2 rounded ml-2 cursor-pointer"
              onClick={() => {
                setTodos(todos.filter((e, index) => index != _index));
              }}
            >
              삭제
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}

rootElement.render(<App />);
```

- 기존에 구현된 코드에서 투두를 추가하면 ul내부에 li태그로 추가된다
- 여기에 버튼을 달았고 onClick이 발생하면 정의되어있는 람다식이 실행된다.
- 지금 버튼이 속해있는 todo의 index와 일치하는 요소만 제외한 새로운 todo배열을 만들어 setTodos로 집어넣어준다.
- 그럼 리엑트가 리랜더링해서 삭제버튼을 누른 요소를 제외한 리스트를 렌더링한다.

🔧 추가로 알면 좋은 포인트(AI)

1. 불변성 유지

- filter는 원래 배열을 건드리지 않고 새 배열을 만듭니다.
- 이게 React에서 상태 업데이트 시 권장되는 방법입니다. (push 대신 filter, map, 스프레드 문법 등)

2. key 값

- 지금은 인덱스를 key로 쓰고 있는데, 삭제/추가가 잦은 리스트라면 고유 id를 key로 주는 게 더 안전합니다.
- 인덱스를 쓰면 React가 어떤 항목이 바뀌었는지 헷갈려서 예상치 못한 UI 동작이 생길 수도 있어요.

### 컴포넌트로 분리

```jsx
function TodoItem({ _index, _todo, removeTodoItem }) {
  return (
    <li key={_index} className="p-2">
      <span>- {_todo}</span>
      <button
        className="p-2 border-2 rounded ml-2 cursor-pointer"
        onClick={() => {
          removeTodoItem(_index);
        }}
      >
        삭제
      </button>
    </li>
  );
}
```

- 기존에 App()에 과하게 들어있던 기능을 분리해서 TodoItem 컴포넌트로 분리했다. 필요한 요소들을 받아주고 적절하게 사용한다.
- 개별 todo를 담는 li부분과 삭제 버튼 로직을 수행한다.

```jsx
function App() {
  const [todos, setTodos] = useState(["책 읽기", "CS 공부", "알고리즘 풀기"]);

  const onSubmitHandle = (e) => {
    e.preventDefault();

    const form = e.target;

    addTodoItem(form.query.value);

    form.query.value = "";
    form.query.focus();
  };

  const addTodoItem = (value) => {
    setTodos([value, ...todos]);
  };

  const removeTodoItem = (index) => {
    setTodos(todos.filter((e, _index) => index != _index));
  };

  return (
    <>
      <form target="_blank" onSubmit={onSubmitHandle}>
        <input
          name="query"
          type="text"
          placeholder="할 일을 등록해주세요."
          className="p-2 border-2 rounded"
        />
        <input
          type="submit"
          value="등록"
          className="p-2 border-2 rounded ml-2"
        />
      </form>
      <ul>
        {todos.map((_todo, _index) => (
          <TodoItem
            key={_index}
            _index={_index}
            _todo={_todo}
            todos={todos}
            removeTodoItem={removeTodoItem}
          />
        ))}
      </ul>
    </>
  );
}

rootElement.render(<App />);
```

- 기존에 컴포넌트 내부에서 람다로 구현하던 todo 추가, 삭제를 함수로 분리했다(addTodoItem, removeTodoItem)
- todos.map으로 돌면서 각 항목을 TodoItem으로 렌더링한다.
- TodoItem은 대응되는 요소를 props로 전달받는다
- key={\_index}로 각 항목을 구분한다. 람다식 ()안에 두번쨰 요소는 배열의 인덱스를 주기로 jsx에서 정해놨다

## 헷갈리던 부분 개념 정리

### 컴포넌트: React에서 UI를 만드는 최소 단위

- 재사용 가능한 화면 조각임.
- 함수처럼 생겼고 JSX를 반환한다.

```jsx
function Button(){
  return <button?>클릭!</button>;
}
```

➡️ Button이라는 컴포넌트는 태그를 그려주는 역할

### props(properties) = 컴포넌트에 전달되는 데이터

- 컴포넌트를 "함수"라고 생각하면, props는 "함수의 매개변수"같은 것

```jsx
function Button({ text }) {
  return <button>{text}</button>;
}
```

```jsx
<Button text="저장" />
<Button text="취소" />
```

➡️ 첫 번째는 <button>저장</button>을 그려줌
➡️ 두 번째는 <button>취소</button>을 그려줌

여기서 전달되는 {text}가 props다!

### 코드에서 \<TodoItem removeTodoItem={removeTodoItem} />

왼쪽 removeTodoItem ➡️ props의 이름, TodoItem컴포넌트로 넘겨줄 속성 이름

오른쪽 {removeTodoItem} ➡️ App 컴포넌트 안에 있는 변수/함수, App에서 정의한 removeTodoItem함수를 그대로 전달하는 것

### TodoItem에서 props받기

```jsx
function TodoItem(props) {
  // App에서 넘긴 props는 이렇게 들어와요
  // props = { removeTodoItem: (App의 removeTodoItem 함수 참조) }

  console.log(props.removeTodoItem); // 함수가 출력됨
}
```

➡️ App에서 넘긴 removeTodoItem함수는 props.removeTodoItem이라는 이름으로 사용할 수 있다!

➡️ 위의 코드 설명에서는 removeTodoItem 라는 동명의 props에 함수(컴포넌트)를 넘긴것이다

### 구조분해 할당(Destructuring)

[구조분해할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring)

매번 props.removeTodoItem이라 하기 귀찮으니 함수 인자에서 바로 구조분해하서 쓴다.

```jsx
function TodoItem({ removeTodoItem }) {
  // 이제 removeTodoItem만 바로 사용 가능
  removeTodoItem(1); // App에서 넘어온 함수 실행
}
```

- 구조분해 할당이란 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JS표현식이라고 한다.
- 배열이나 객체나 뭐든지 간에 **이름(key)**에 맞춰서 전달받은 props와 내부 변수를 대응시킨다.

js에서는 기본적으로 아래와 같은 방식으로 사용되고

```js
const obj = { a: 10, b: 20 };

const { b, a } = obj;
console.log(a); // 10
console.log(b); // 20
```

jsx문법에서는 아래와 같이, 본 예제코드와 같이 작동한다.

```jsx
function TodoItem({ text, index, removeTodoItem }) {
  console.log(text); // "책 읽기"
  console.log(index); // 1
  console.log(removeTodoItem); // fn
}
```
