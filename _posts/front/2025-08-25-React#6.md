---
title: "[프론트 기초]홀짝 카운터 구현"
date: 2025-08-25 09:00:00 +0900
categories: [React]
tags: [react, javascript, frontend]
---
## 홀짝 카운터

```jsx
// React import랑 DOM객체 초기화는 생략

function App() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <div className="text-2xl">number: {number}</div>
      <div>{number % 2 == 0 ? "짝수" : "홀수"}</div>
      <button
        className="p-2 border-2 rounded"
        onClick={() => {
          setNumber(number + 1);
        }}
      >
        증가
      </button>
    </>
  );
}

rootElement.render(<App />);
```

- onClick()에 setNumber로 number 업데이트해줌
- react가 이걸 보고있다가 업데이트해줌
- 위에 두개의 \<div> 태그에는
  - 첫번째꺼 -> number값을 그대로 표시
  - 두번째꺼 -> 삼항연산자로 참이면 "짝수", 거짓이면 "홀수"로 렌더링

```
✅ React의 실제 동작
1. 상태(state) 저장소
- React는 useState로 선언한 값들을 **컴포넌트 함수 바깥(React 내부 메모리 공간)**에 저장해둡니다.
- 컴포넌트 함수가 다시 실행될 때도 이 값들은 사라지지 않고 유지돼요.

2. setState 호출
- setNumber(...) 같이 상태 변경 함수를 호출하면 React는
- 새로운 값으로 상태 저장소를 갱신하고
- **해당 컴포넌트를 다시 실행(렌더링)**합니다.

3. 다시 실행될 때
- 컴포넌트 함수(App 같은 함수)를 아예 새로 호출해서 JSX를 다시 계산합니다.
- 이때 JSX 안에서 {number}처럼 상태 변수가 들어간 곳은 그 시점의 최신 상태값으로 다시문자열/- M 트리에 반영됩니다.
- 즉, “어디에 쓰였는지 추적해서 거기만 바꾼다”기보다는, 컴포넌트 전체를 다시 실행해서 Virtual DOM 트리를 새로 만들고, 이전 트리와 비교(diff)해서 필요한 부분만 실제 DOM에 반영하는 구조예요.

📌 오해 풀기
-	오해: React가 {} 안에서 변수를 “감시(watch)”하다가 값이 변하면 그 자리만 고쳐준다?
-	실제: React는 변수를 실시간 감시하지 않아요.
-	setState가 호출돼야만 “이 컴포넌트 다시 렌더해야겠다”라고 결정.
-	컴포넌트 함수 전체를 다시 실행해서 JSX를 새로 만들고 → 이전 Virtual DOM과 비교 → 바뀐 부분만 실제 DOM에 반영.

🚗 비유
-	JSX = 설계도
-	useState = 설계도에 들어갈 값들을 React가 따로 들고 있는 창고
-	setState = 창고에 값 바꾸고, 설계도를 다시 그려 달라고 React에 요청
-	React = 새 설계도와 기존 설계도를 비교해서 “바뀐 부분만” 시공하는 시공업자
```
