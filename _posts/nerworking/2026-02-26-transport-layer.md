---
title: "[네트워킹]전송 계층(Transport Layer) - TCP, UDP, 혼잡 제어"
date: 2026-02-26 12:00:00 +0900
categories: [CS]
tags: [networking, tcp, udp, transport-layer, congestion-control]
---

컴퓨터 네트워킹 하향식 접근의 Chapter 3 Transport Layer를 정리한 내용입니다.

# 3.1 전송 계층 서비스

전송 계층은 서로 다른 호스트에서 실행되는 애플리케이션 프로세스 간에 마치 직접 연결된 것과 같은 논리적 통신(Logical Communication)을 제공한다. 라우터가 아닌 종단 시스템(Host)끼리 구현되며, 송신 측에서는 애플리케이션 메시지를 작은 조각으로 나누고 헤더를 추가해 전송 계층 패킷인 세그먼트(Segment)를 생성하여 네트워크 계층으로 전달한다.

## 전송 계층과 네트워크 계층의 관계

- 통신 주체의 차이: 네트워크 계층은 호스트 간(Host-to-Host)의 논리적 통신을 제공 ↔ 전송 계층은 호스트 내에서 실행되는 프로세스 간(Process-to-Process)의 논리적 통신을 제공
- 의존성과 독립성: 전송 계층이 제공할 수 있는 서비스는 기반이 되는 네트워크 계층 프로토콜이 제공하는 서비스 모델에 제약을 받음(대역폭 보장이나 지연 시간 보장 불가)
- 네트워크 계층이 신뢰할 수 없는(Unreliable) 서비스더라도, 전송 계층은 패킷 손실 회복 등을 통해 애플리케이션에 신뢰적 데이터 전송(Reliable Data Transfer)이나 암호화를 통한 보안과 같은 부가적인 서비스를 독자적으로 제공할 수 있다.

## 인터넷 전송 계층의 개요

인터넷은 애플리케이션 계층에 두 가지 서로 다른 계층 프로토콜을 제공한다. 네트워크 계층 프로토콜인 IP(Internet Protocol)는 Best-effort(난 이만큼 하면 최선을 다함)전달 서비스로, 패킷의 순서나 수신을 보장하지 않는 Unreliable(비신뢰적) 서비스이다. 전송 계층의 가장 기본적인 역할은 이러한 IP의 호스트 간 전달을 프로세스 간 전달로 확장하는 다중화와 역다중화이며, 추가적인 서비스에 따라 두 프로토콜로 나뉜다.

- UDP(User Datagram Protocol): 신뢰성이 없고 연결을 맺지 않는(Connectionless)서비스. 다중화/역다중화와 간단한 오류 검사(Error checking)라는 최소한의 기능만 제공하며 패킷의 도달이나 순서를 보장하지 않는다.
- TCP(Trasmission Control Protocol): 신뢰적이고 연결 지향적인(Connection-oriented)서비스. 흐름제어, 순서 번호, 확인 응답(ACK), 타이머 등을 사용하여 순서가 맞고 손실 없는 신뢰적 데이터 전송을 보장한다. 또한, 네트워크 전체의 혼잡을 막기 위해 송신 속도를 조절하는 혼잡제어(Congestion Control)기능을 포함한다.

---

# 3.2 다중화와 역다중화(Multiplexing and Demultiplexing)

수신 측 호스트에는 여러 네트워크 애플리케이션이 동시에 돌아가고 있을 수 있다. 데이터는 프로세스로 직접 전달되는 것이 아니라 출입구(인터페이스) 역할을 하는 소켓(Socket)으로 전달된다.

- 역다중화(Demultiplexing): 수신 측 전송 계층이 하위의 네트워크 계층에서 수신한 세그먼트의 데이터를 알맞은 소켓으로 정확하게 전달하는 작업.
- 다중화(Mutiplexing): 송신 측 전송 계층이 여러 소켓에서 데이터를 모으고, 각 데이터에 나중에 역다중화에 사용될 헤더 정보(출발지/목적지 포트 번호)를 덧붙여 세그먼트를 생성한 후 네트워크 계층으로 내려보내는 작업.

이를 위해 각 소켓은 16비트로 구성된 고유한 포트 번호(Port Number)를 할당받는다(0~65535)

0~1023번의 포트번호는 HTTP(80), FTP(21)등 널리 알려진 애플리케이션을 위해 예약된 잘 알려진 포트 번호(Well-known port numbers)

https://datatracker.ietf.org/doc/html/rfc3232

https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml

→ 교재에는 RFC 3232에 문서로 예약된 포트들을 관리하는 것으로 나오지만,

→ 인터넷이 폭발적으로 성장하며 포트 번호가 수시로 바뀌게 되고 문서로 상태관리가 어려워져 IANA의 온라인 데이터베이스를 통해 실시간으로 관리된다고 한다.

## 비연결형(Connectionless) 다중화와 역다중화 | UDP

- 2튜플 식별: UDP 소켓은 `(목적지 IP 주소, 목적지 포트 번호)` 의 두 가지 요소로 구성된 2튜플에 의해서만 식별된다.
- 동일 소켓 도착: 출발지 IP주소나 출발지 포트 번호가 다르더라도, 목적지 IP와 포트 번호가 같다면 두 UDP 세그먼트는 수신 측의 동일한 소켓(동일한 프로세스)으로 전달된다.
- 세그먼트에 포함된 출발지 포트 번호는 수신자가 송신자에게 답장을 보낼 때 반송주소(Return Address)의 용도로 사용된다.

## 연결 지향형(Connection-Oriented) 다중화와 역다중화 | TCP

- 4튜플 식별: TCP 소켓은 `(출발지 IP주소, 출발지 포트 번호, 목적지 IP주소, 목적지 포트 번호)` 의 4튜플로 식별된다.
- 독립적 소켓 생성: 수신 측 호스트는 이 4가지 값을 모두 확인하여 역다중화를 수행. 즉, 여러 클라이언트가 웹 서버의 같은 목적지 포트(예: HTTP, 80)로 동시에 연결을 요청하더라도, 각 클라이언트의 출발지 IP나 포트번호가 다르므로 서버는 이들을 각각 서로 다른 전용 연결 소켓으로 매핑하여 분리한다.

## 웹 서버와 TCP

- 웹 서버(Apache 등)는 80번 포트에서 클라이언트의 연결 요청(대기 소켓)을 기다린다.
- 클라이언트로부터 TCP 연결 요청(SYN)이 들어오면 서버는 출발지 IP와 포트번호를 기반으로 해당 클라이언트만을 위한 새로운 연결 소켓(또는 스레드)을 생성하여 통신
- 지속(Persistent) HTTP를 사용하면 클라이언트와 서버가 같은 소켓을 유지한 채 여러 HTTP메시지를 교환하지만, 비지속(Non-persistent) HTTP를 사용하면 요청/응답마다 새로운 TCP 연결과 소켓이 생성되고 닫히므로 바쁜 웹 서버에 심각한 성능 부하를 줄 수 있음.

---

# 3.3 비연결형 전송: UDP(User Datagram Protocol)

UDP는 IP(네트워크 계층)에 다중화/역다중화 기능과 간단한 오류 검출 기능만을 추가한, 가장 단순하고 가벼운 전송 계층 프로토콜

## UDP를 사용하는 이유(TCP 대비 장점)

TCP가 신뢰성을 제공함에도 불구하고 특정 애플리케이션들이 해당 프로토콜을 사용하는 이유

- 애플리케이션 레벨의 정교한 제어: UDP는 혼잡 제어(Congestion Control)을 하지 않으므로, 데이터가 준비되는 즉시 네트워크 계층으로 전송. 실시간 스트리밍이나 게임처럼 약간의 데이터 손실은 허용하되, 지연 없는 전송률이 중요한 경우에 적합하다.
- 연결 설정 지연 없음(No connection establishment): TCP의 3-Way handshake와 같은 사전 연결 과정이 없어 지연 시간이 없다. DNS나 HTTP/3(QUIC)가 UDP를 기반으로 동작하는 가장 큰 이유
- 연결 상태 유지 안함(No connection state): TCP처럼 수신/송신 버퍼, 혼잡 제어 파라미터, 순서 번호 등의 상태를 저장할 필요가 없어 서버가 더 많은 클라이언트를 동시 수용할 수 있다.
- 작은 패킷 헤더 오버헤드: TCP헤더는 20바이트 ↔ UDP헤더는 8바이트

## UDP 세그먼트 구조와 체크섬

- 헤더 구조: 출발지 포트, 목적지 포트, 길이(헤더 포함 바이트 수), 체크섬으로 구성되며 각각 2바이트씩 총 8바이트로 구성
- 체크섬(Checksum): 데이터가 전송되는 동안 링크의 노이즈나 라우터 메모리에서 비트가 훼손되었는지 오류를 검출한다. 세그먼트 안의 16비트 워드들을 더한 후, 오버플로를 랩어라운드(Wrap-around)하고 1의 보수를 취하여 구한다.
- 종단 간 원칙(End-End Principle): 하위 링크 계층에서 오류 검출을 제공하더라도, 라우터 메모리 등에서 발생하는 오류를 잡기 위해 전송 계층에서도 독립적인 오류 검출이 필수적임을 보여주는 대표적인 설계 원리이다.

---

# 3.4 신뢰적 데이터 전송의 원리(RDT, Reliable Data Transfer)

신뢰할 수 없는 하위 채널(IP) 위에서 데이터의 손실이나 손상 없이 패킷을 순서대로 전달하기 위한 프로토콜 발전 과정

## RDT 프로토콜의 진화 과정

- rdt 1.0 (완벽한 채널): 오류도 없고 패킷 손실도 없는 완벽한 채널을 가정. 데이터를 받아서 전송하기만 하면된다.
- rdt 2.0(비트 오류가 있는 채널): 패킷 손실은 없으나 비트가 훼손될 수 있음
    - 해결책(ARQ 프로토콜): 오류 검출(체크섬), 수신자 피드백(ACK-긍정, NAK-부정), 재전송을 도입한다. 하지만 ACK나 NA자체에 오류가 발생하면 송신자는 수신 상태를 알수 없는 결함이 남아있다.
- rdt 2.1 & 2.2: ACK/NAK 손상을 해결하기 위해 순서 번호(Seqence Number)를 도입하여 수신자가 중복 패킷인지 새로운 패킷인지 식별하게 한다. rdt 2.2에서는 NAK를 없애고 ACK에 순서 번호를 포함시켜 동일한 효과를 내다.
- rdt 3.0(비트 오류와 패킷 손실이 있는 채널): 패킷이 아예 유실될 수 있음
    - 해결책(타이머): 송신자는 패킷을 보내고 카운트다운 타이머를 작동시킨다. 일정시간(Timeout)내에 ACK가 오지 않으면 패킷을 재전송

## 파이프라이닝(Pipelining)과 윈도우 프로토콜

rdt 3.0은 패킷을 하나 보내고 ACK를 기다리는 전송 후 대기(Stop-and-Wait)방식으로, 링크 대역폭을 심각하게 낭비한다. 이를 해결하기 위해 ACK를 기다리지 않고 여러 패킷을 연달아 전송하는 파이프라이닝을 사용

- Go-Back-N(GBN):
    - 송신자는 최대 N개(윈도우 크기)의 확인받지 않은 패킷을 파이프라인에 둘 수 있음
    - 수신자는 연속적으로 잘 받은 마지막 패킷에 대해서만 누적 확인응답(Cumulative ACK)를 보낸다. 순서가 어긋난 패킷은 저장안하고 버림
    - 타임아웃 발생 시, 송신자는 확인받지 못한 모든 패킷을 재전송(Go-Back)한다.

- 선택적 반복(Selective Repeat, SR):
    - GBN은 불필요한 재전송이 발생가능, 비효율
    - 수신자는 받은 패킷 각각에 대해 개별적인 ACK를 보내고, 순서가 어긋난 패킷은 임시로 버퍼링한다.
    - 송신자는 패킷마다 개별 타이머를 가지며, 손실된(또는 손상된) 특정 패킷만 선택적으로 재전송

# 3.5 연결 지향형 전송: TCP(Transmission Control Protocol)

## TCP 세그먼트의 구조 (순서 번호와 확인응답)

- TCP는 데이터를 패킷의 모음이 아닌 바이트 스트림으로 취급한다
- 순서 번호(Sequence Number): 패킷 단위가 아니라, 해당 세그먼트 데이터의 첫 번째 바이트 번호
- 확인응답 번호(Acknowledgement Number): 수신자가 발신자로부터 다음으로 받기를 기대하는 바이트 번호. TCP는 기본적으로 GBN처럼 누적 확인응답을 사용하고, SR방식을 혼용한다.

## 타임아웃 주기 산정(RTT Estimation)

TCP에서 재전송 타이머를 설정하기 위해서, 패킷이 왕복하는 시간보다 약간 길게 잡는 계산 과정을 거침

- SampleRTT: 특정 세그먼트가 송신되고 ACK가 돌아올 때까지의 시간
- EstimatedRTT: 네트워크의 변동성을 고려해서 지수 가중 이동 평군(EWMA)을 사용하여 과거 RTT와 현재 SampleRTT를 혼합해 평균을 구함
- TimeoutInterval: `EstimatedRTT + 4 * DevRTT(변동성)` 공식을 통해, 네트워크 환경에 적응형으로 타임아웃 주기를 동적 설정한다.

## 신뢰적 데이터 전송과 빠른 재전송(Fast Retrasmit)

- 단일 타이머 사용: TCP는 이론상의 SR과 달리 오버헤드(모든 세그먼트에 각각 타이머)를 줄이기 위해, 확인받지 못한 가장 오래된 세그먼트에 대한 단일 타이머만 사용한다.
- 타임아웃 시 백오프: 타임아웃이 발생하면 패킷을 재전송할 때 타이머 주기를 2배로 늘려 네트워크 혼잡을 완화한다.
- 빠른 재전송(Fast Retransmit): 타임아웃은 주기가 길어 지연이 심하다. 만약 수신자가 중간에 패킷을 잃어버리고 뒤이은 패킷들을 연속으로 받으면, 빈 공간을 알리기 위해 동일한 확인응답 번호(중복 ACK)를 계속 보낸다. 송신자가 3개의 중복 ACK(총 4개의 동일한 ACK)를 받으면 타임아웃이 나기 전이라도 해당 패킷이 유실되었다고 판단하고 즉시 재전송한다.

## 흐름 제어(Flow Control)

송신자가 수신자의 처리 속도보다 데이터를 너무 빨리 보내 수신 버퍼가 오버플로되는 것을 방지하는 송신 속도 조절 매커니즘

- 수신자는 자신이 현재 받을 수 있는 버퍼의 여유 공간을 세그먼트 헤더의 수신 윈도우(`rwnd`)필드에 담아 송신자에게 알려준다. 송신자는 전송한 데이터 중 아직 확인받지 않은 양이 `rwnd` 를 초과하지 않도록 제어한다.

## 연결 관리(TCP 3-Way Handshake)

데이터 전송 전, 클라이언트와 서버는 양방향 통신을 위한 버퍼와 상태 변수, 초기 순서 번호(ISN)를 할당하기 위해 3-Way Handshake 과정을 거친다.

1. SYN: 클라이언트가 `SYN` 비트를 1로 설정하고 자신의 초기 순서번호(`client_isn`)를 담아 보냄.
    - ISN(Initial Sequence Number)의 목적:
        - 패킷 순서 맞추기: 네트워크를 통해 쪼개져 날아오는 패킷들을 원래 순서대로 조립하기 위한 번호표
        - 과거 패킷과 혼동 방지: 이전에 만들었던 연결에서 지연되어 뒤늦게 도착한 패킷과 혼동 방지함
        - 세션 하이재킹(TCP Sequence Prediction Attack) 방지: 번호가 1,2,3처럼 예측 가능하면 공격자가 가짜 패킷을 쉽게 끼워 넣을 수 있으므로 랜덤하게 만드는 거임.
2. SYNACK: 서버는 연결을 수락하며 버퍼를 할당하고, `SYN` 비트 1, 자신의 초기 순서번호(`server_isn`), 그리고 클라이언트의 `ISN+1` 을 ACK 번호로 담아 보낸다.
3. ACK: 클라이언트가 서버의 SYN에 대해 확인응답(ACK)를 보낸다. (이때 데이터 포함 가능)

> TCP 3-Way Handshake를 악용한 공격 기법인 SYN Flooding과 TCP Connection Flood에 대해서는 [별도 포스트](/posts/syn-flooding-attack/)에서 다룬다.

---

# **3.6 ~ 3.7 TCP 혼잡 제어 (Congestion Control)**

흐름 제어가 수신자를 위한 것이라면, 혼잡 제어는 네트워크 전체의 병목과 큐 넘침을 방지하기 위한 송신자 측의 제어 기법이다. TCP 송신자는 혼잡 윈도우(`cwnd`)라는 변수를 조절하여 네트워크에 주입하는 데이터 속도를 제어한다.

- AIMD 원리: 문제없을 때는 선형적으로 속도를 올리고(Additive Increase), 패킷 손실이 발생하면 속도를 절반으로 뚝 떨어뜨립니다(Multiplicative Decrease). 이로 인해 톱니바퀴 모양의 대역폭 사용 그래프가 나온다.
- 혼잡 제어의 3단계:
    1. Slow Start (슬로우 스타트): 연결 초기나 타임아웃 직후 `cwnd`를 1부터 시작하되, ACK를 받을 때마다 지수적으로(2배씩) 급격히 창 크기를 늘려 임계치(`ssthresh`)까지 도달한다.
    2. Congestion Avoidance (혼잡 회피): `cwnd`가 임계치(`ssthresh`)에 도달하면 선형적(1 RTT당 1 MSS)으로 조심스럽게 크기를 증가시킨다.
    3. Fast Recovery (빠른 회복) - TCP Reno: 3 Duplicate ACK에 의한 손실 감지 시, `cwnd`를 절반으로 줄이고(타임아웃처럼 1로 떨어뜨리지 않음) 빠른 회복 상태로 진입하여 선형 증가를 재개합니다 (TCP Tahoe는 무조건 1로 떨어뜨림).
- 현대의 혼잡 제어 (TCP CUBIC): 오늘날 리눅스의 기본 방식으로, 혼잡 발생 시 절반으로 떨어뜨린 후 최대 윈도우 크기까지 3차 함수(Cubic) 형태로 빠르게 증가시키고 그 이후엔 천천히 증가시켜 대역폭을 낭비 없이 사용

# 3.8 전송 계층 기능의 진화 (QUIC)

TCP의 한계(느린 3-Way Handshake 및 TLS 설정 지연, HOL Blocking)를 극복하기 위해 등장한 구글의 차세대 프로토콜

- QUIC (Quick UDP Internet Connections): UDP 위에서 애플리케이션 계층으로 신뢰성, 혼잡 제어, 암호화를 모두 구현한 프로토콜이다(HTTP/3의 기반).
- 특징:
    - 스트림 독립성 다중화: 단일 연결 내에서 여러 스트림을 전송하여, 한 패킷이 손실되더라도 다른 스트림(이미지, CSS 등)은 멈추지 않고 전송되는 HOL Blocking 문제 해결
    - 빠른 연결: TCP 3-Way Handshake와 TLS 핸드셰이크를 결합하여 1-RTT 혹은 0-RTT 만에 보안 연결을 맺고 즉시 데이터를 보낼 수 있음
