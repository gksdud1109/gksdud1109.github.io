---
title: "Redis 기초 - 인메모리 데이터 저장소의 개념과 특징"
date: 2025-12-07 12:00:00 +0900
categories: [Database]
tags: [database, redis, cache, in-memory, nosql]
---

## 개요

Redis는 오픈 소스 인메모리 데이터베이스로, 데이터를 **키-값(Key-Value) 쌍 형태로 저장**한다. 모든 데이터를 메모리(RAM)에 저장하여 디스크 I/O 지연을 제거함으로써 매우 빠른 읽기/쓰기 성능을 제공한다. 이 글에서는 Redis의 기본 개념, 특징, 영속성 옵션을 정리한다.

---

## 1. Redis 개념 (인메모리 데이터 저장소)

Redis(레디스)는 **Remote Dictionary Server**의 약자로, 원격에서 접근 가능한 해시 테이블 기반 저장소를 의미한다. 개별 애플리케이션 서버들이 네트워크를 통해 하나의 Redis 서버에 연결하여 공통된 데이터 저장소로 활용할 수 있다.

### Redis의 주요 활용 분야

- 페이지 뷰 집계
- 실시간 세션 정보
- 캐싱

Redis는 NoSQL 데이터베이스의 일종으로 스키마 없이 유연한 데이터 모델을 가지며, 수평적 확장이 용이하다.

---

## 2. Redis의 특징

### 2.1 메모리 기반 고속 성능

Redis의 가장 큰 장점은 모든 데이터를 **메모리에 저장**하기 때문에 응답 속도가 매우 빠르다는 점이다. 일반적인 디스크 DB보다 수백 배 이상의 속도를 보여준다.

다만 메모리는 휘발성이라 전원이 차단되면 내용이 사라질 수 있으므로, **주로 캐시(cache)처럼 영구적 보관이 필요 없는 일시적인 데이터**를 다루는 용도로 활용된다.

> 자주 참조되지만 변경이 빈번하지 않은 데이터를 Redis에 두고, 영구 저장은 관계형 DB에 병행하는 패턴으로 많이 사용된다.

### 2.2 단일 스레드 아키텍처

Redis 서버 코어는 **싱글 스레드(Single-thread)로 동작**한다. 하나의 스레드가 요청을 차례로 처리하므로, 동시에 둘 이상의 연산이 겹쳐 실행되지 않아 데이터 일관성이 자연스럽게 보장된다.

**장점:**
- 모든 연산이 **원자적(atomic)**으로 수행
- 레이스 컨디션에 안전

**주의점:**
- 복잡하거나 대용량 처리가 필요한 명령을 실행하면 그 동안 다른 요청을 처리하지 못함
- `KEYS *` 같은 명령은 완료될 때까지 다른 명령을 블로킹

### 2.3 다양한 데이터 타입과 기능 지원

Redis는 단순 문자열뿐만 아니라 다양한 데이터 구조를 값으로 저장할 수 있다.

| 데이터 타입 | 활용 예시 |
|------------|----------|
| List | 대기열(큐), 스택 |
| Set | 유일한 항목들의 컬렉션 |
| Sorted Set | 자동 정렬 랭킹 리스트 |
| Hash | 객체 속성 저장 |
| Bitmap | 비트 플래그 관리 |
| HyperLogLog | 대량 카운팅 |
| Stream | 실시간 로그 수집 |

또한 **PUB/SUB (발행-구독) 메시징 기능**이 내장되어 있어 실시간 채팅, 알림 방송과 같은 이벤트 분산 처리를 손쉽게 구현할 수 있다.

---

## 3. 데이터 영속성 옵션 (RDB와 AOF)

기본적으로 메모리에 존재하는 Redis 데이터는 서버 종료 시 사라지지만, Redis는 데이터 영속성(Persistence)을 위해 두 가지 저장 방식을 제공한다.

### RDB (Redis Database)

일정 주기마다 메모리 전체 내용을 스냅샷 뜨듯이 덤프하여 `.rdb` 파일로 저장하는 방식이다.

**장점:**
- 장애 발생 시 해당 시점으로 빠르게 복원 가능
- 다른 서버에 파일 배포하여 데이터가 미리 채워진 인스턴스 생성 가능

**단점:**
- 스냅샷 주기 사이에 발생한 변경분은 유실 위험
- 대용량 메모리 환경에서 스냅샷 시 성능 저하 가능

### AOF (Append Only File)

발생하는 모든 쓰기(write) 연산 자체를 로그에 순차적으로 기록하는 방식이다.

**장점:**
- RDB보다 데이터 정합성을 더 최근까지 보존 가능
- 모든 연산 기록

**단점:**
- 복구 시 로그의 처음부터 끝까지 재실행해야 함
- 로그 파일 크기 증가

> 일반적으로 캐싱 목적의 Redis는 영속성을 끄거나 RDB만 사용하며, 중요한 데이터를 Redis에 상주시킬 경우 AOF를 병행 설정한다.

---

## 4. 복제와 클러스터를 통한 확장

### Replication (복제)

- 하나의 Redis 마스터 서버에 여러 개의 슬레이브 서버를 둘 수 있음
- 슬레이브들은 마스터의 데이터를 실시간 복제
- **읽기 부하 분산(읽기 스케일 아웃)**에 활용
- **Sentinel 기능**으로 마스터 장애 시 슬레이브 자동 승격 가능

### Cluster 모드

- Redis 데이터를 여러 노드에 **샤딩(sharding)** 방식으로 분산 저장
- 키 공간을 해시 슬롯으로 분할하여 각 노드가 담당
- 메모리 용량과 처리량을 수평 확장 가능

---

## 5. Redis 활용 사례

| 활용 분야 | 설명 |
|----------|------|
| 캐싱(Caching) | 빈번하게 조회되는 데이터를 임시 저장하여 DB 부하 감소 |
| 세션 관리(Session Store) | 로그인 세션 정보를 저장, TTL로 자동 만료 처리 |
| 실시간 랭킹/카운트 | 게임 스코어보드, 조회수, 좋아요 수 집계 |
| 메시지 큐/브로커 | List, Stream, Pub/Sub을 활용한 간단한 메시지 큐 |
| 분산 락 구현 | 여러 서버 간 동시성 제어 |

---

## 6. Redis 사용상의 한계와 주의점

1. **메모리 기반 특성**
   - 데이터 저장 비용이 높고 용량 한계
   - 물리 메모리를 초과하는 데이터는 저장 불가

2. **단일 스레드**
   - 연산 시간이 긴 명령어는 전체 성능에 영향
   - 시간 복잡도가 높은 명령들은 주의해서 사용

3. **메모리 단편화**
   - 삽입과 삭제가 빈번하면 내부적으로 메모리 단편화 발생 가능
   - 모니터링을 통해 메모리 사용량 관리 필요

---

## 7. 문자열(String) 기본 명령어

Redis를 처음 접할 때 가장 기본이 되는 데이터 타입이 문자열(String)이다.

```bash
# SET 명령어로 문자열 데이터 설정
SET mykey "Hello, Redis!"

# GET 명령어로 저장된 데이터 조회
GET mykey
# 출력: "Hello, Redis!"

# INCR 명령어로 숫자형 값 증가
SET counter "1"
INCR counter
# 출력: (integer) 2

# MSET으로 여러 키-값 한 번에 설정하고, MGET으로 조회
MSET key1 "value1" key2 "value2"
MGET key1 key2
# 출력:
# 1) "value1"
# 2) "value2"
```

---

## 정리

1. Redis는 **인메모리 키-값 저장소**로 초고속 데이터 액세스 제공
2. **단일 스레드** 아키텍처로 원자성 보장, 동시성 제어 단순화
3. **다양한 자료구조** 지원으로 개발 편의성 향상
4. **RDB/AOF**로 영속성 선택 가능
5. **복제와 클러스터**로 확장성과 고가용성 확보
6. 캐싱, 세션 관리, 실시간 랭킹 등 다양한 분야에서 활용

---

## 참고

- [Redis 기본정리](https://velog.io/@rlaghwns1995/Redis-%EA%B8%B0%EB%B3%B8%EC%A0%95%EB%A6%AC)
- [Redis란 무엇일까? - Redis의 특징과 사용 시 주의점](https://velog.io/@wnguswn7/Redis%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
- [Redis란? 레디스의 기본적인 개념](https://wildeveloperetrain.tistory.com/21)
- [[NHN FORWARD 2021] Redis 야무지게 사용하기](https://www.youtube.com/watch?v=92NizoBL4uA)
