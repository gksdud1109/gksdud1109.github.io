---
title: "[알고리즘]백준 2579_계단 오르기"
excerpt: "계단 오르기"

categories:
  - Algorithm

date: 2025-08-18
last_modified_at: 2025-08-18
---

[문제링크](https://www.acmicpc.net/problem/2579)

풀이

```java
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] st = new int[305]; // 계단 점수
        int[][] dp = new int[305][3];
        int N = sc.nextInt();

        for(int i=1;i<=N;i++)
            st[i] = sc.nextInt();

        dp[1][1] = st[1]; dp[1][2] = 0;
        dp[2][1] = st[2]; dp[2][2] = st[1]+st[2];

        for(int i=3; i<=N; i++){
            dp[i][1] = Math.max(dp[i-2][1], dp[i-2][2]) + st[i];
            dp[i][2] = dp[i-1][1] + st[i];
        }

        System.out.println(Math.max(dp[N][1], dp[N][2]));
    }
}
```

- 옛날에 풀어봤던 문제라 바로 작성했습니다..
- dp[i][1] → i번째 계단에 오기까지 직전계단은 밟지 않은 경우 == 2계단을 점프한 경우
- dp[i][2] → i번째 계단에 오기는데 직전계단을 밟은 경우 == 전계단에서 1계단 올라온 경우
- 점화식
  - 초기값
    dp[1][1] = st[1]; → 1번째 계단에 도착, 직전 계단은 밟지 않음 == 첫번째 계단 점수 <br/>
    dp[1][2] = 0; → 1번째 계단에 도달하는데 직전계단이 있을 수 없음 == 0 <br/>
    dp[2][1] = st[2]; → 2번째 계단에 도착, 직전 계단은 밟지 않음 == 두번째 계단 점수 <br/>
    dp[2][2] = st[1]+st[2]; → 2번째 계단에 도착, 직전계단을 밟음 <br/>
  - dp[i][1] = Math.max(dp[i-2][1], dp[i-2][2]) + st[i]; <br/>
    → i-2번째 칸에서의 점수 + i번째 칸의 점수
  - dp[i][2] = dp[i-1][1] + st[i];<br/>
    → i-1번째 칸의 점수 + i번째 칸의 점수<br/>
    → dp[i-1][2]는 포함시키지 않음으로서 3계단 연속 밟는 경우는 피함
- N가지 계산하면, dp[N][1]과 dp[N][2] 둘중에 최대값이 계산되게 됩니다.

### 오늘 배운 점👓

- 점화식이 직관적이지 않음, 더 깔끔하고 직관적인 풀이가 가능할 것도 같은데 고민해봐야겠다.
