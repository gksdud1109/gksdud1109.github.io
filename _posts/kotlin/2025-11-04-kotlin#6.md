---
title: "[Kotlin#6] 코틀린 궁금한 점 & 기초문법 정리"
date: 2025-11-04 09:00:00 +0900
categories: [Kotlin]
tags: [programming, kotlin]
---
기존 자바 코드
```java
public class ServiceException extends RuntimeException {

    private String resultCode;
    private String msg;

    public ServiceException(String resultCode, String msg) {
        super("%s : %s".formatted(resultCode, msg));
        this.resultCode = resultCode;
        this.msg = msg;
    }

    public String getResultCode() {
        return resultCode;
    }

    public String getMsg() {
        return msg;
    }

    public RsData getRsData() {
        return new RsData(resultCode, msg);
    }
}
```

kotlin으로 바꾼 코드
```kotlin
class ServiceException(
    val resultCode: String,
    val msg: String?
) : RuntimeException("${resultCode} : ${msg}") {
    val rsData: RsData<*>
        get() = RsData<Any?>(resultCode, msg)
}
```


# 클래스 정의 한 줄씩 이해하기

### 생성자 파라미터 = 프로퍼티

-	`val resultCode: String`, `val msg: String?`
  -	생성자 인자이자 곧바로 클래스의 읽기 전용 프로퍼티(필드)로 선언됨.
  -	어디서든 e.resultCode, e.msg로 접근 가능.

### `: RuntimeException("${resultCode} : ${msg}")`

-	ServiceException은 RuntimeException을 상속.
-	상위 생성자에 "코드 : 메시지"를 넘김 → 예외 객체의 표준 메시지가 됨.
  -	로그/스택트레이스에 찍히는 e.message는 바로 이 문자열.


### `val rsData: RsData<*>`

-	읽기 전용 프로퍼티. **실제 필드가 아니라 “계산되는 프로퍼티”**
-	아래 get()이 호출될 때마다 새 RsData를 만들어서 돌려줌.
-	즉, e.rsData를 읽을 때마다 실시간 생성.

### `get() = RsData<Any?>(resultCode, msg)`

-	커스텀 getter. resultCode와 msg를 담은 응답 래퍼 객체를 즉석에서 생성.
-	`RsData<Any?>`를 `RsData<*>`로 노출해 타입을 넓힘(와일드카드).<br>
→ 호출자는 data를 쓰지 않아도 되며, JSON 응답의 모양을 통일하기 쉬움.

### 커스텀 getter 정의

일반적으로 Kotlin에서 이렇게 쓰면:

```kotlin
val name = "한영"
```

이건 단순히 값을 저장하는 필드임.

그런데 이렇게 쓰면:

```kotlin
val name get() = "한영"
```

이건 필드가 아니라 함수임
즉, name을 읽을 때마다 "한영"을 리턴하는 getter 함수가 호출됌.

자바식으로 표현하면 아래와 같음

```java
public RsData<?> getRsData() {
    return new RsData<>(resultCode, msg);
}
```

### `RsData<Any?>(resultCode, msg)` — 객체 생성

-	여기서 RsData는 클래스 이름
-	`<Any?>`는 제네릭 타입 인자임.
-	Any는 Kotlin의 모든 타입의 최상위 클래스 (Java의 Object와 비슷).
-	Any?는 “null도 될 수 있는 Any” → 즉, 모든 타입 다 허용.
-	(resultCode, msg)는 생성자 인자.

즉, RsData<Any?>(resultCode, msg)는
resultCode와 msg 값을 넣어서 새 RsData 객체를 하나 만드는 코드임.

<hr>

# 실제 요청–응답 흐름으로 보기

## 1. 어딘가의 서비스/필터에서 예외 던짐

예: API 키가 유효하지 않을 때

```kotlin
if (!isValidApiKey) {
    throw ServiceException("401-3", "API 키가 유효하지 않습니다.")
}
```

이때 예외 객체 내부 상태
-	e.resultCode == "401-3"
-	e.msg == "API 키가 유효하지 않습니다."
-	e.message == "401-3 : API 키가 유효하지 않습니다."  ← 로그/스택트레이스용

## 2. 전역 예외 처리기에서 받음

```kotlin
@ExceptionHandler(ServiceException::class)
@ResponseBody
fun handleException(e: ServiceException): RsData<Void?> {
    // 아래 두 줄은 완전히 동일한 의미
    // return RsData(e.resultCode, e.msg)
    return e.rsData
}
```

여기서 e.rsData 접근 → getter가 실행되어 즉시 RsData(resultCode, msg)가 새로 만들어짐.

## 3. 컨트롤러 응답(JSON)으로 내려감

RsData를 JSON으로 직렬화하면 대략 이렇게:

```json
{
  "resultCode": "401-3",
  "msg": "API 키가 유효하지 않습니다.",
  "data": null
}
```
> 포인트: 비즈니스 로직 예외를 던지면, 전역 핸들러가 항상 같은 형태의 JSON으로 바꿔주게 설계되어 있음.

# 자주 하는 실수 & 팁

-	msg가 String?(nullable)이라 null일 수도 있음.
  -	응답 JSON에 "msg": null이 싫다면, 전역 핸들러에서 기본 메시지로 치환해도 됨.
-	동일한 예외를 다른 곳에서 재사용할 때 resultCode 체계를 문서화해두면 테스트/운영 양쪽에서 훨씬 편함.
-	rsData는 매번 새 인스턴스를 만들지만 가벼운 객체라 부담 거의 없음(그리고 응답 직렬화 직전에 한 번만 호출됨).


# Kotlin ↔ Java 코드 비교


| 역할 | Kotlin 코드 | Java 대응 코드 |
|:----|:----|:----|
|클래스 정의 및 상속 | class ServiceException(...) : RuntimeException(...)| public class ServiceException extends RuntimeException|
|프로퍼티 정의 | val resultCode: String, val msg: String? | private String resultCode; private String msg; |
|상위 생성자 호출 (메시지 설정) | RuntimeException("${resultCode} : ${msg}") |super("%s : %s".formatted(resultCode, msg)); 
| 프로퍼티 초기화 |Kotlin은 자동으로 필드에 대입 | this.resultCode = resultCode; this.msg = msg; | 
|게터 자동 생성 | Kotlin에서는 val만 써도 getResultCode() / getMsg() 자동 생성 | Java는 직접 getResultCode(), getMsg() 작성 |
| 응답용 RsData 변환 게터 | val rsData get() = RsData<Any?>(resultCode, msg) | public RsData getRsData() { return new RsData(resultCode, msg); } |
