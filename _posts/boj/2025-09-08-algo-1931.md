---
title: "[알고리즘]백준 1931_회의실 배정"
excerpt: "그리디"

categories:
  - Algorithm

date: 2025-09-08
last_modified_at: 2025-09-08
---

[문제 링크](https://www.acmicpc.net/problem/1931)

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer tokenizer = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(tokenizer.nextToken());
        List<int[]> list = new ArrayList<>(N);

        for (int i = 0; i < N; i++) {
            tokenizer = new StringTokenizer(br.readLine());
            list.add(new int[]{
                    Integer.parseInt(tokenizer.nextToken()),
                    Integer.parseInt(tokenizer.nextToken())});
        }

        list.sort(
                Comparator.comparingInt((int[] arr) -> arr[1])
                .thenComparingInt(arr -> arr[0])
        );

        int count = 0, lastEndTime = 0;

        for (int[] m : list) {
            int start = m[0], end = m[1];
            if (start >= lastEndTime) {
                lastEndTime = end;
                count++;
            }
        }

        System.out.println(count);
    }
}
```

- 특정 시점에서 회의 일정을 선택해 가능한 많은(최대의) 회의 스케줄을 잡으려면
  - 가장 빨리 끝나는 회의를 선택하면 됩니다.</br>
    → 가장빨리 끝나는 회의를 선택해야 회의가 하나라도 더 들어가기 때문</br>
    → 목적이 가능한 많은 회의 스케줄을 잡는거니까!
- 위와 같이 선택하면 계속해서 해당 회의가 끝나는 시점 이후로 다시 가장빨리 끝나는 회의를 선택하는걸 반복해서 최대 회의수를 구합니다
- 정렬: 처음에는 가장 빨리 끝나는, 종료시간 순으로만 정렬했습니다
  - 중간에 빈텀이 생기더라도 회의수가 같기 때문에 동률의 경우에 시작시간은 상관 없는 것으로 생각했습니다.
  - 실제로 시작시간에 대해 정렬하지 않아도 결과는 동일한 것을 확인했지만 혹시 모를 입력이 이상하거나, 종료시간이 같은 경우에 예외적으로 시작시간으로 회의수가 달라지는 경우가 걱정되어서 시작순 정렬도 해주었습니다.
- 특정 회의가 끝나면 종료시간 이후 시작하는 회의중 가장빨리 끝나는 회의를 선택하는 로직을 구현하면 됩니다.
