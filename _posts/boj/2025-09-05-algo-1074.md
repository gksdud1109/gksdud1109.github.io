---
title: "[알고리즘]백준 1074_"
excerpt: "DP"

categories:
  - Algorithm

date: 2025-08-20
last_modified_at: 2025-08-22
---

[문제 링크](https://www.acmicpc.net/problem/1074)

```java
import java.util.*;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int r = sc.nextInt();
        int c = sc.nextInt();

        int size = (int) Math.pow(2, N);

        int result = zsearch(size, r, c);
        System.out.println(result);
    }

    static int zsearch(int size, int r, int c){
        if(size == 1) return 0;

        int half = size / 2;
        if(r < half && c < half)   return zsearch(half, r, c);
        else if(r < half && c >= half) return (half*half) + zsearch(half, r, c-half);
        else if(r >= half && c < half) return 2*(half*half) + zsearch(half, r-half, c);
        else return 3*(half*half) + zsearch(half, r-half, c-half);
    }
}
```

> 풀이

[![1074.png](https://i.postimg.cc/DfB1Czf4/1074.png)](https://postimg.cc/23LqyrZC)

- 이렇게 저렇게 재귀구조로 구현해보다가 도저히 시간이 너무 오래걸려서 풀이를 봤습니다
- 4개의 사분면을 재귀구조로 나타내고 방문 순서를 꼭 저장할 필요가 없이 오프셋으로 접근하는게 핵심이었다고 생각합니다.
- 가장 작은 단위는 2\*2의 평면이고 코드에 나타난 4개의 if-else구조중에
  - 0은 첫번째 if문에 걸립니다<br/>
    `if(r < half && c < half)`<br/>
    `return zsearch(half, r, c);`
  - 1은 두번째 if문에 걸립니다<br/>
    `else if(r < half && c >= half)`<br/>
    `return (half*half) + zsearch(half, r, c-half);`
  - 2는 세번째 if문에 걸립니다.<br/>
    `else if(r >= half && c < half)`<br/>
    `return 2*(half*half) + zsearch(half, r-half, c);`
  - 3은 네번째 if문에 걸립니다. <br/>
    `else`<br/>
    `return 3*(half*half) + zsearch(half, r-half, c-half);`
  - 사실 가장 말단에서 리턴되는 베이스 컨디션은 size==1일때이지만 어차피 리턴값이 0이라 최소 단위는 2\*2라 생각하는게 편한것 같습니다.
- 그 이후가 핵심인데 4\*4의 1, 2, 3, 4사분면 또한 2\*2에서의 1,2,3,4와 같은 로직으로 if문에 걸려 리턴값을 냅니다.
- 예를 들어 그림에 우측을 보면 파란표시로 글자를 해놓은 것 처럼 half로 2사분면의 오프셋 4를 계산할 수 있습니다.
- 그럼 [4+(해당 사분면에서 r,c좌표의 위치가 0,1,2,3중에 대응되는값)]이 해당 좌표의 방문순서라 할 수 있습니다.
- 이때 r,c좌표가 해당 사분면에서 0,1,2,3중에 어디에 대응되는지 찾는 연산은 왼쪽그림을 보면 알 수 있습니다.<br/>
  → 1사분면(x, y) == 2사분면(x, y-half) == 3사분면(x-half, y) == 4사분면(x-half, y-half)<br/>
  → 마치 선형대수학에서 행렬로 좌표계를 나타내는 것과 유사한 것 같습니다
- 더 큰 8\*8의 사각형에서 또한 1,2,3,4사분면으로 나누어 속한 값만큼 half값 연산으로 인덱스를 뛰어넘고 해당되는 값을 더해주면 됩니다.
- 이런식으로 재귀구조가 쌓이면서 해당되는 위치의 값들이 계속해서 누적으로 더해지게 됩니다.
- 사실 설명보다 그림을 보면 훨씬 빠를 것 같습니다
