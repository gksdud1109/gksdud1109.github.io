---
title: "[알고리즘]그리디_백준 2217_로프"
date: 2026-02-21 15:30:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/2217)

```c++
#include <bits/stdc++.h>
using namespace std;

int N;
int w[100005];

int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);
  cin >> N;
  for(int i=0; i<N; i++) cin >> w[i];
  sort(w, w+N);
  int ans = 0;
  for(int i=1; i<=N; i++)
    ans = max(ans, w[N-i]*i);
  
  cout << ans;
}
```

## 헷갈린 부분

풀이 코드에서 `w[N-i]*i`로 되어있는 부분이 같은 로프를 여러개 고르는 걸로 오해했음.

## 풀이 핵심 원리

문제 조건: </br>
***k개의 로프를 사용하여 중량이 W인 물체를 들어 올릴 때, 각각의 로프에는 모두 고르게 W/k만큼의 중량이 걸림.***

-> 내가 고른 로프들 중에 가장 약한 로프가 전체 하중의 한계치를 결정한다는 뜻이다

### 예시
버틸 수 있는 중량이 `10`, `100`, `1000`인 로프 3개를 골랐을 경우,

- 세 로프에 똑같이 무게가 나뉘기 때문에, 가장 약한 `10` 로프가 끊기지 않으려면 각 로프에 최대 10까지만 무게를 줄 수 있음

- `100`,`1000`짜리 로프가 있음에도, 결국 각자 최대 `10`까지만 부담할 수 있으므로 전체 들 수 있는 무게는 `10 * 3 = 30`

### 풀이 코드 `w[N-1]*i`

코드에서 로프를 버틸 수 있는 중량순으로 오름차순 정렬 했다.
그리고 뒤에서부터(가장 튼튼한 로프부터)하나씩 추가하면서 묶어보는 것.

- `w[N-1]`: 최대 중량이 1등으로 큰 로프
- `w[N-2]`: 최대 중량이 2등으로 큰 로프
- `w[N-i]`: 최대 중량이 i등으로 큰 로프

> 여러 로프를 병렬로 묶으면 하중이 동일하게 분산되므로, `선택된 로프 중 가장 약한 로프 중량 한계치 * 선택한 로프의 개수`가 해당 묶음의 최대 하중이 된다. 따라서 가장 튼튼한 로프부터 개수를 하나씩 늘려가며 최댓값을 갱신해주면 된다.
