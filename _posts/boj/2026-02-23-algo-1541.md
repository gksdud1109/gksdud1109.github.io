---
title: "[알고리즘]DP_백준 1541_잃어버린 괄호"
date: 2026-02-23 23:30:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/1541)

```c++
#include <bits/stdc++.h>
using namespace std;

int tmp, ans;
int sign = 1;

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);

  string input;
  cin >> input;
  for(char c: input){
    if(c=='+' || c=='-'){
      ans += tmp*sign;
      if(c=='-') sign=-1;
      tmp = 0;
    }
    else{
      tmp *= 10;
      tmp += c - '0';
    }
  }
  ans += tmp * sign;
  cout << ans;
}
```

최소를 만들려면 최대한 큰 값을 빼야한다. 첫 뺄셈 기호 이후의 모든 값은 괄호를 적절히 활용해 뺄셈으로 바꿀 수 있으므로, `-`가 등장하는 순간 뒤에 덧셈들을 다 묶어버리는게 그리디 포인트

## 원리

식에 `-`가 한 번이라도 등장하면, 그 뒤에 나오는 숫자들은 괄호를 어떻게 치느냐에 따라 전부 마이너스로 만들수 있다.

- 예시: `55 - 50 + 40 - 30 + 20`
- 괄호 치기: `55 - (50+40) - (30+20)`

이렇게 `-`뒤에 모든 `+`들이 괄호에 묶여 최대한 작은 수를 만들 수 있도록 최대한 큰수를 뺄셈 처리할 수 있게 된다.

## 시뮬레이션

- `tmp`: 현재 읽고 있는 숫자를 저장(`5`, `0`이 연속으로 오면 50을 만듦)
- `ans`: 최종 결과값 저장
- `sign`: 지금 숫자를 더할지(1), 뺄지(-1) 결정하는 플래그

### 예시: `55 - 50 + 40`

1. `5`, `5` 읽기: `tmp`는 55가 된다.

2. `-` 만남: 지금까지 만든 `tmp(55)`를 `ans`에 더한다.
  - 중요! `-`를 만났으므로 이제부터 나오는 모든 숫자는 플래그를 이용해 최대한 큰수를 만들어 뺄셈 처리
  - `tmp`는 0으로 초기화 함

3. `5`, `0` 읽기: `tmp`는 50

4. '+' 만남:
  - `ans += tmp * sign` -> `55 + (50 * -1) = 5`
  - `sign`은 이미 -1, `c == '-'` 일 때만 바꾸므로, `+`를 만나도 `sign`은 여전히 -1을 유지한다. (그리디 포인트!)
  - `tmp`는 0으로 초기화합니다.

5. `4`, `0` 읽기: `tmp`는 40
6. 루프 종료 후: 남아있는 `tmp`를 처리한다. `ans += 40 * -1` → `5 - 40 = -35.`