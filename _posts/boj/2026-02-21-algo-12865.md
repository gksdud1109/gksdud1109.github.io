---
title: "[알고리즘]DP_백준 12865_평범한 배낭"
date: 2026-02-21 16:30:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/12865)

```c++
#include <bits/stdc++.h>
using namespace std;

int N, K;
int W[105], V[105];
int D[100005]; // D[j]: 배낭의 허용 무게가 j일때 담을 수 있는 최대 가치

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);

  cin >> N >> K;

  for(int i=1; i<=N; i++){
    cin >> W[i] >> V[i];
  }

  for(int i=1; i<=N; i++){
    for(int j=K; j>=W[i]; j--){
      D[j] = max(D[j], D[j-W[i]] + V[i]);
    }
  }

  cout << D[K];
  return 0;
}
```

## 0-1 knapsack이 그리디로 해결안되는 이유

그리디로 접근한다면 보통 무게 대비 가치가 가장 높은 물건, 또는 가치가 높은(비싼) 물건 등으로 골라 담을 것이다.

하지만 물건을 쪼갤 수 없는 상황이기 때문에, **특정 물건을 포기해야만 더 작은 물건 여러 개를 담아 이득을 보는 상황이 발생함.**

이 때문에 그리디가 성립하지 않고, 모든 경우의 수를 기록하는 DP를 써야한다.

## 1차원 DP배열 풀이

`D[j]: 배낭의 최대 허용 무게가 j일 때 담을 수 있는 최대 가치`

```c++
for(int i=1; i<=N; i++){           // 바깥쪽 루프: 1번 물건부터 N번 물건까지 차례대로 본다
  for(int j=K; j>=W[i]; j--){      // 안쪽 루프: 현재 배낭 용량 j를 K부터 줄여가며 확인한다
    D[j] = max(D[j], D[j-W[i]] + V[i]);
  }
}
```

- `i`(1~N): 물건의 번호, 1~N까지 하나씩 검사
- `j`(K-W[i]): 물건이 아니라, 배낭이 버틸 수 있는 무게
- `D[j]`: 배낭의 허용 용량이 j일 때 담을 수 있는 최대 가치

***지금 i번째 물건을 택하려 한다면, 배낭의 최대 무게가 K일 때, K-1일 때, ... W[i]일 때 각각 이 물건을 넣는게 이득일까?***

## 시뮬레이션

- 배낭 최대 용량(K): 7
- 초기 배열 상태: 모두 0
`D = [0,0,0,0,0,0,0]`
- 나머지는 문제 예시 입력과 동일

### 물건 1번 넣기(무게 6, 가치 13)
배열의 오른쪽(7)부터 무게 6까지만 검사
- j=7: `D[7] = max(D[7], D[7-6]+13)` -> `max(0, D[1]+13) = 13`
- j = 6: `D[6] = max(D[6], D[6-6] + 13)` -> `max(0, D[0] + 13) = 13`

▶ 1번 물건 처리 후 배열 상태:
`D = [0, 0, 0, 0, 0, 0, 13, 13]`

### 물건 2번 넣기 (무게 4, 가치 8)

현재 배열 상태를 그대로 둔 채, 다시 오른쪽(7)부터 무게 4까지만 검사

- j = 7: `D[7] = max(13, D[7-4] + 8)` -> `max(13, D[3] + 8)`= 13
- j = 6: `D[6] = max(13, D[6-4] + 8)` -> `max(13, D[2] + 8)` = 13
- j = 5: `D[5] = max(0, D[5-4] + 8)` -> `max(0, D[1] + 8)` = 8
- j = 4: `D[4] = max(0, D[4-4] + 8)` -> `max(0, D[0] + 8)` = 8

▶ 2번 물건 처리 후 배열 상태: `D = [0, 0, 0, 0, 8, 8, 13, 13]`


### 물건 3번 넣기 (무게 3, 가치 6) - ★ 여기가 핵심!

현재 배열은 `[0, 0, 0, 0, 8, 8, 13, 13]`

- j = 7: `D[7] = max(D[7], D[7-3] + 6)`
  - 현재 D[7]은 13
  - D[4]는 8 (아까 2번 물건이 넣어둔 값)
  - 따라서 max(13, 8 + 6) = 14. (13보다 크므로 14로 덮어쓴다!)
  
- j = 6: D[6] = `max(13, D[3] + 6)` -> `max(13, 0 + 6) = 13`
- j = 5: D[5] = `max(8, D[2] + 6)` -> `max(8, 0 + 6) = 8`
- j = 4: D[4] = `max(8, D[1] + 6)` -> `max(8, 0 + 6) = 8`
- j = 3: D[3] = `max(0, D[0] + 6)` -> `max(0, 0 + 6) = 6`

▶ 3번 물건 처리 후 배열 상태: `D = [0, 0, 0, 6, 8, 8, 13, 14]`

이 과정을 통해 D 배열 하나만으로도 이전 상태의 값들을 훼손하지 않고 안전하게 정답을 누적해 나갈 수 있다


### `W[i]`에서 멈추는 이유
배낭의 용량 `j`를 점차 줄여나가다가, `j`가 현재 물건의 무게인 `W[i]`보다 작아지면?

-> 애초에 배낭 용량이 물건 무게보다 작아서 물건을 물리적으로 넣기가 불가능한 상황이 됌

### 🚨 왜 오른쪽(뒤)에서 왼쪽(앞)으로 역순으로 가야만 할까?
만약 물건 3번(무게 3, 가치 10으로 가정)을 앞에서부터(j=3부터 7까지) 검사했다면 어떤 오류가 발생하는지 생각해본다.

초기 배열은 2번 물건까지 마친 `[0, 0, 0, 0, 8, 8, 13, 13]` 상태

- j = 3: `D[3] = max(0, D[0] + 10) = 10`
(배열이 `[0, 0, 0, 10, 8, 8, 13, 13]` 으로 변함)

- j = 6: 루프가 계속 돌아 j=6이 된다면,
  - `D[6] = max(D[6], D[6-3] + 10)` -> `D[6] = max(13, D[3] + 10)`
  - D[3]은 방금 전 j=3일때 10으로 갱신되었다! 따라서 m`ax(13, 10 + 10) = 20`이 되어버리는 문제가 발생

분명 무게 3짜리 물건은 단 하나뿐인데, 앞에서부터 채우면 방금 넣었던 물건을 또 참조하게 되어 배낭에 같은 물건이 2번 들어가는 버그가 생긴다.

하지만 뒤(j=7)부터 계산하면, 내가 참조해야 할 앞쪽 인덱스(D[4], D[3] 등)는 아직 이번 물건의 영향을 전혀 받지 않은 ***'과거의 깨끗한 상태'***임이 보장되어 역순으로 구현하는 것임!