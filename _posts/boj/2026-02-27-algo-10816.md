---
title: "[알고리즘]이분탐색_백준 10816_숫자 카드2"
date: 2026-02-27 12:20:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/10816)

```c++
#include <bits/stdc++.h>
using namespace std;

int a[500005];
int N;

int lower_idx(int target, int len){
  int st=0;
  int en=len;
  while(st<en){
    int mid=(st+en)/2;
    if(a[mid] >= target) en = mid;
    else st=mid+1;
  }
  return st;
}
int upper_idx(int target, int len){
  int st=0;
  int en=len;
  while(st<en){
    int mid=(st+en)/2;
    if(a[mid]>target) en=mid;
    else st=mid+1;
  }
  return st;
}

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  cin >> N;
  for(int i=0; i<N; i++) cin >> a[i];
  sort(a,a+N);
  int M; cin >> M;
  while(M--){
    int t; cin >> t;
    cout << upper_idx(t,N)-lower_idx(t,N) << '\n';
  }
}
```

Lower Bound와 Upper Bound의 개념/구현 한번에 딱! 잘 이해가 안된다.

## `binary_search` STL을 쓰면 안되는 이유
배열에 `[1, 2, 2, 2, 3]`처럼 같은 값이 여러 개 있다면 인덱스만 반환하는 STL로는 전체 개수를 알 수 없음
- 비효율적인 방법: 찾은 위치에서 왼쪽, 오른쪽으로 하나씩 가며 세기 -> 최악의 경우 O(N)(모든 숫자가 같은 경우)
- 효율적인 방법: 숫자가 시작되는 지점과 끝나는 지점을 이분탐색 -> O(logN)

## Lower Bound와 Upper Bound
숫자를 삽입해도 오름차순이 유지되는 위치를 찾으면 된다.
- `lower_idx`(Lower Bound): 특정 숫자 `target`이 나타나는 가장 첫 번째 위치.(만약 없다면 `target`보다 큰 숫자가 처음 나타나는 위치)

- `upper_idx`(Upper Bound): 특정 숫자 `target`보다 처음으로 큰 숫자가 나타나는 위치

## 코드 if 조건문이 다른 이유

### 1. `lower_idx`: 가장 왼쪽 찾아야함
```c++
if(a[mid] >= target) en = mid;
else st = mid+1;
```
- 의미: 만약 `a[mid]`가 내가 찾는 숫자보다 크거나 같다면, 정답은 `mid`를 포함해서 왼쪽에 있을 것.
- 결과: 숫자가 중복될 때 계속 왼쪽으로 범위를 좁히기 때문에, 가장 왼쪽에 있는 인덱스에서 멈춘다.

### 2. `upper_idx`: 가장 오른쪽 찾아야함
```c++
if(a[mid] > target) en = mid;
else st = mid+1;
```
- 의미: `a[mid]`가 내가 찾는 숫자보다 클 때만 왼쪽을 본다. 만약 같다면, 오른쪽을 찾아본다(`st=mid+1`)
- 결과: 숫자가 중복될 때 st를 오른쪽으로 밀어내기 때문에, 해당 숫자들보다 큰 숫자가 처음 나오는 위치에서 멈춘다.

### 결국 이분탐색을 이용해 경계선을 찾는 것

---

## `lower_bound`, `upper_boud`는 STL에 이미 구현되어 있음

```c++
int count = upper_bound(a, a + N, t) - lower_bound(a, a + N, t);
```

별도 함수 구현없이 STL사용해 아래처럼 작성하면 풀이 코드와 동일한 동작을 한다.


```c++
while(m--){
  int t; cin >> t;
  cout << upper_bound(a, a+N, t) - lower_bound(a, a+N, t) << '\n';
}
```