---
title: "[알고리즘]투포인터_백준 1644_소수의 연속합"
date: 2026-02-28 21:00:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/1644)

```c++
#include <bits/stdc++.h>
using namespace std;

const int MXN = 4000002;
vector<bool> seive(MXN, true);
vector<int> primes;

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);

  for(int i=2; i*i<MXN; i++){
    if(!seive[i]) continue;
    for(int j= i*i; j<MXN; j+= i)
      seive[j] = false;
  }

  for(int i=2; i<MXN; i++)
    if(seive[i]) primes.push_back(i);
  primes.push_back(0);

  int target, st=0, en=1, ans=0, tmpSum=primes[0];
  cin >> target;
  while(1){
    if(tmpSum >= target){
      if(tmpSum == target) ans++;
      tmpSum -= primes[st++];
    }
    if(tmpSum < target) tmpSum += primes[en++];
    if(en == int(primes.size())) break;
  }

  cout << ans;
}
```

## 사전작업: 일단 소수를 구별해야함.(에라어쩌구의 체)

```c++
  for(int i=2; i*i<MXN; i++){
    if(!seive[i]) continue;
    for(int j= i*i; j<MXN; j+= i)
      seive[j] = false;
  }
```

- `seive`: 400만(문제에서 N의 범위)까지의 숫자가 소수인지 아닌지를 체크하는 불리언 배열
- 원리: 2부터 시작해서 2의 배수를 전부 지우고, 3의 배수 전부 지우고, ... 남는 것들이 소수
- 결과: `primes` 벡터에 소수들만 차례로 담기게 된다.

## 투 포인터로 합 찾기

`while(1)`을 돌면서 애벌레(비유)가 움직인다.

### 애벌레의 움직임
- `tmpSum`: 현재 애벌레가 차지하고 있는 구간의 합
- `target`: 만들고 싶은 숫자, 문제에서 `N`으로 주어지는 수
- if문 1(`tmpSum >= target`):
  - 합이 목표치 이상이되면(`>=`) 다음으로 움직인다.
  - 목표치에 딱 맞는 케이스(`==`)에서는 정답 카운트를 올린다.
  - `tmpSum -= primes[st++]`: 맨 뒤에 있던 소수를 빼서 다음 구간으로 한 칸 이동
- if문 2(`tmpSum < target`): 
  - 합이 목표보다 작다면 계속 머리(`en`)를 움직이며 구간합을 더한다.
- if문 3(탈출 조건): 머리(`en`)가 준비된 소수 리스트의 끝에 도달하면 탐색 종료

## 코드의 디테일

1. `primes.push_back(0)`:
  - while문 안에서 `primes[e++]`를 할 때, 배열의 범위를 넘어가서 에러가 나는 것을 방지하기 위한 더미 데이터.
  - 머리가 배열 끝에 도달했을 때 안전하게 종료하기 위함.

2. `while(1)`에서 종료 조건
  - 머리(`e`)가 소수 리스트의 끝까지 다 갔다면(`e`가 리스트 사이즈의 크기 즉, 끝까지 이동했다면), 더 이상 합을 크게 만들 수 없으므로 탐색을 종료

## 시뮬레이션 (target = 20일 때)
소수 리스트: `[2, 3, 5, 7, 11, 13, 17, 19, ...]`

1. `2`에서 시작. (tmpSum=2)
2. 2는 20보다 작으니 머리를 밀어서 3을 더함. (tmpSum=5)
3. ... 계속 머리를 민다. (tmpSum = 2+3+5+7 = 17)
4. 여전히 20보다 작으니 11을 더한다 (tmpSum = 28)
5. 28 > 20이므로 꼬리를 뺀다. (tmpSum = 26)
6. ... 여전히 구간합이 크므로 3, 5 차례로 꼬리를 뺀다(tmpSum = 18)
8. 18 < 20이므로 `target`이 나올 수 없음 머리를 밀어 다음 소수를 더한다...

이런 식으로 애벌래가 소수 배열 위를 꿈틀거리며(슬라이딩 윈도우) **중복계산 없이** 합이 20이 되는 순간을 다 찾아낼 수 있음.
