---
title: "[알고리즘]DP_백준 10844_쉬운 계단 수"
date: 2026-02-19 16:00:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/9461)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int N;
ll D[101][10];
const int mod = 1000000000;

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  cin >> N;
  
  for(int i=1; i<=9; i++) D[1][i] = 1;

  for(int i=2; i<=N; i++){
    for(int k=0; k<=9; k++){
      if(k!=0) D[i][k] += D[i-1][k-1];
      if(k!=9) D[i][k] += D[i-1][k+1];
      D[i][k] %= mod;
    }
  }

  ll ans = 0;
  for(int i=0; i<=9; i++)
    ans += D[N][i];

  ans %= mod;
  cout << ans;
}
```

## 계단 수

인접한 모든 자릿수의 차이가 1인 수
- 맞는 예시: `456`, `878`, `1212`, `101`
- 틀린 예시: `13`(차이가 2), `55`(차이가 0)

문제의 목표는 길이가 N인 계단 수가 총 몇개인지 구하는 것!


## 핵심 규칙: 내 옆에 올 친구 찾기

1. 내가 지금 자리에 `3`을 썼다면, 뒤에 올 수 있는 숫자는 `2` 아니면 `4` 밖에 없음
2. 내가 지금 자리에 `0`을 썼다면, 뒤에 올 수 있는 숫자는 오직 `1` 하나뿐
3. 내가 지금 자리에 `9`를 썼다면, 뒤에 올 수 있는 숫자는 오직 `8` 하나뿐

## DP로 푸는 원리

`D[길이(자릿수)][끝나는 숫자]`
- `D[2][3]`: 길이가 2이면서 마지막 숫자가 3인 계단수의 개수(`23`, `43`)

## 시뮬레이션

### N=1 일 때 (한 자리 수)
0으로 시작하는 수는 없으므로, 1~9까지 각각 1개씩 있다.

- `D[1][1]=1, D[1][2]=1, ..., D[1][9]=1` (0은 안 됨)

### N=2 일 때 (두 자리 수)
이제 이 숫자들 뒤에 1 차이 나는 숫자를 붙여봄

- 뒤에 0을 붙이고 싶어: 앞에 1이 있었어야 함 → `D[1][1]`의 개수만큼 생김 (1개: `10`만 가능)

- 뒤에 1을 붙이고 싶어: 앞에 0이나 2가 있었어야 함 → `D[1][0] + D[1][2]`만큼 생김 (1개: `21`, `D[1][0]`은 0이니까)

- 뒤에 2를 붙이고 싶어: 앞에 1이나 3이 있었어야 함 → `D[1][1] + D[1][3]`만큼 생김 (2개: `12`, `32`)

- ... (이런 식으로 8까지 반복) ...

- 뒤에 9를 붙이고 싶어: 앞에 8이 있었어야 함 → `D[1][8]`의 개수만큼 생김 (1개: `89`)

### N=3 일 때 (세 자리 수)
- 뒤에 1을 붙이고 싶어: 앞에 0이나 2로 끝난 두 자리 수가 있어야 함.
  - 아까 0으로 끝난 두 자리 수는 1개(`10`), 2로 끝난 두 자리 수는 2개(`12`, `32`)였음!
  - 그래서 총 3개(`101`, `121`, `321`)가 된다!