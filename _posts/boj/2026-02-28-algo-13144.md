---
title: "[알고리즘]투포인터_백준 13144_List of Unique Numbers"
date: 2026-02-28 21:00:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/13144)

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);
  
  int N; cin >> N;

  vector<int> arr(N);
  vector<bool> chk(100'002);

  for(int i=0; i<N; i++) cin >> arr[i];
  long long ans = 0;
  int en=0;
  for(int st=0; st<N; st++){
    while(en<N-1 && !chk[arr[en+1]]){
      en++;
      chk[arr[en]] = 1;
    }
    ans += (en-st+1);
    chk[arr[st]] = 0;
  }
  cout << ans;
}
```

## 핵심 아이디어: 내가 끝(en)을 정하면 그 사이 모든 구간은 정답이다

예를 들어, 수열이 `[1, 2, 3]`인 경우:
- 시작할 때, st=0이고, en을 밀어보니 중복없이 끝까지 간다.
- 그럼 st=0에서 시작해서 중복이 없는 구간은:
  - `[1]`
  - `[1, 2]`
  - `[1, 2, 3]`
- 총 3개, 이 구간을 한꺼번에 더해(`en-st+1`) 답을 구한다.

st를 고정했을 때, 최대한 멀리 갈 수 있는 en을 찾으면, 그 사이에 있는 모든 짧은 구간들도 자동으로 중복이 없는 정답이 된다는 뜻!

## 코드 로직

① `chk` 배열: 아까 나온 숫자인지 기억하는 배열
`vector<bool> chk(100'002)`는 현재 애벌레 몸통 안에 어떤 숫자가 들어있는지 체크하는 지도

새로운 숫자(`arr[en+1]`)를 먹기 전에 `chk`를 확인해서, 이미 있으면 머리(`en`)를 멈춘다.

② `while`문:
```C++
while(en < N - 1 && !chk[arr[en+1]]){
  en++;
  chk[arr[en]] = 1; // 먹었으니까 체크
}
```
머리(`en`)를 중복이 발생하기 직전까지 최대한 멀리 보낸다

③ `ans += (en - st + 1)`: 정답 적립
위에서 설명한 대로, 현재 st에서 시작해 en까지 갈 수 있는 모든 경우의 수를 한 번에 더한다.

④ `chk[arr[st]] = 0`: 꼬리 자르기
이제 `st`를 다음 칸으로 옮길 거니까, 현재 st가 가리키던 숫자는 몸통에서 빠집니다. 그래서 chk를 다시 0(false)으로 바꿔줍니다.

## 주의할 점

1. `long long` 사용: `N`이 10만일 때 정답은 약 50억까지 나올 수 있다. int 범위를 넘어가기 때문에 ans는 반드시 long long이어야 함

2. `en < N - 1`과 `en+1`: 머리를 미리 한 칸 앞질러 보고(en+1) 갈 수 있는지 판단하는 로직이라 인덱스가 조금 헷갈린다.

## 시뮬레이션: `[1, 2, 1]`

1. st=0(값 1): `en`이 1까지 감. (값 2는 중복 아님)
  - `en`이 2까지 가려니 값 1이 중복, 스톱.
  - `en=1`에서 멈춤. `ans += (1-0+1)` -> ans = 2 (`[1], [1,2]`)
  - `chk[1]` 해제
  
2. st=1 (값 2): 
  - `en`은 아까 1에 있었다. 다음 칸(`en=2`, 값 1)을 보니 이제 중복이 아님!(아까 해제했으니까)
  - `en=2`까지 전진
  - `ans += (2-1+1)` -> ans = 2+2 = 4 (`[2], [2,1]`)
  - `chk[2]` 해제
  
3. st=2 (값 1): `en`은 이미 끝에 있음.
  - `ans += (2-2+1)` -> ans = 4+1 = 5 (`[1]`)
  
4. 최종 결과: ans = 5