---
title: "[알고리즘]DP_백준 9461_파도반 수열"
date: 2026-02-19 13:00:00 +0900
categories: [Algorithm]
tags: [problem-solving, boj, algorithm]
---
[문제 링크](https://www.acmicpc.net/problem/9461)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll D[105];
int T;

int main(){
  ios::sync_with_stdio(0);
  cin.tie(0);

  cin >> T;
  D[1] = 1; D[2] = 1; D[3] = 1;

  for(int i=4; i<=100; i++){
    D[i] = D[i-2] + D[i-3];
  }

  while(T--){
    int n;
    cin >> n;
    cout << D[n] << '\n';
  }
}
```

## 첫 제출시의 오답
- D[i]를 `int`로 정의함
- 수열의 증가 속도를 고려하면, N이 커질수록 값의 크기가 급격히 불어난다.
- N=100일 때 `888,855,064,897` -> overflow 발생
- long long(약 $\pm 900$경 ($9 \times 10^{18}$))으로 정의해야함

## 파도반 수열 점화식
[![pandovan.png](https://i.postimg.cc/KYHvm8WQ/pandovan.png)](https://postimg.cc/CZbVNSSf)

- 처음 이미지에서 직관적으로 봤을 때는 `D[i] = D[i-2] + D[i-3]`이 안나옴.
- 오히려 `4의 경우 3+1`, `5의 경우 4+1`처럼 더 복잡한 조건이 있는것처럼 보임
- `D[i] = D[i-1] + D[i-5]`의 점화식도 직관적으로 가능하지만, 초기값 설정이 더 귀찮음(1~5번까지 직접 입력)
- 수열을 놓고 봤을 때, 최종 점화식을 유도할 수 있음.