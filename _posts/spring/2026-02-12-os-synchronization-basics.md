---
title: "OS 동기화 기초 - 임계 구역부터 동기화 도구까지"
date: 2026-02-12 12:00:00 +0900
categories: [Spring]
tags: [os, synchronization, concurrency, mutex, semaphore, monitor]
---

## 개요

동시성 제어를 이해하기 위해서는 OS 수준의 동기화 개념을 먼저 파악해야 한다. 이 글에서는 Operating System Concepts(공룡책) 6장을 기반으로 동기화의 기본 개념부터 동기화 도구까지 정리한다.

---

## 1. 배경 및 문제 정의 (Background)

### 생산자-소비자 문제

```cpp
// Producer
while(true){
    /* produce an item in next produced */
    while(count == BUFFER_SIZE)
      ; /* do nothing */

    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
    count++;
}
```

```cpp
// Consumer
while(true){
  while(count == 0)
    ; /* do nothing */
  next_consumed = buffer[out];
  out = (out + 1) % BUFFER_SIZE;
  count--;
}
```

공룡책 6장 도입부(p257~259)는 동기화(Synchronization)의 필요성을 설명하기 위해 생산자-소비자 문제를 예시로 들고 있다.

위 코드에서 `in`, `out` 두 개의 포인터(변수)가 등장한다.

- `in`: 생산자가 데이터를 넣을 다음 빈칸의 위치
- `out`: 소비자가 데이터를 꺼내갈 채워진 칸의 위치

작동 방식은 다음과 같다.

- 생산자가 데이터를 넣으면 `in`이 한 칸 전진 (`in = (in + 1) % BUFFER_SIZE`)
- 소비자가 데이터를 꺼내면 `out`이 한 칸 전진 (`out = (out + 1) % BUFFER_SIZE`)

여기서 `% BUFFER_SIZE`는 배열의 끝에 도달하면 다시 0번 인덱스로 돌아오는 원형 구조를 구현하기 위함이다.

### 문제가 발생하는 지점

버퍼에 현재 몇 개의 아이템이 있는지 세는 변수(`count`)에서 문제가 발생한다.

- 생산자: 아이템을 추가하고 `count++`
- 소비자: 아이템을 가져가고 `count--`

### 문제 상황 시나리오

1. 생산자: count(5)를 읽어서 레지스터에 넣음
2. 생산자: 레지스터 값을 1 증가시킴 (레지스터 값: 6)
   → 여기서 Context Switch 발생
3. 소비자: count(아직 5임)를 읽어서 레지스터에 넣음 (레지스터 값: 5)
4. 소비자: 레지스터 값을 1 감소시킴 (레지스터 값: 4)
5. 소비자: count에 4를 저장함 (메모리의 count는 4)
   → 다시 생산자에게 Context Switch
6. 생산자: 아까 계산했던 6을 count에 저장함 (메모리의 count는 6)

**결과**: 정상적이라면 5에서 생산자에서 하나 늘고, 소비자에서 하나 감소했으니 5가 되어야 하는데, 결과는 6이 되거나(순서에 따라 4로도 가능) 데이터가 꼬이게 된다. → **Race Condition 발생**

`count++`, `count--`는 고급 언어에서는 한 줄이지만, 기계어 레벨에서는 read → modify → write 세 단계로 나뉘어 실행되기 때문이다.

---

## 2. 임계 구역 (Critical Section)

공유 데이터에 접근하는 코드 영역을 말한다. 한 프로세스가 자신의 임계 구역에서 수행 중일 때, 다른 어떤 프로세스도 그 임계 구역에 들어갈 수 없어야 한다.

### 임계 구역 문제 해결 조건 (3가지 필수 조건)

임계 구역 문제를 해결하기 위한 프로토콜은 다음 세 가지 요구사항을 반드시 만족해야 한다.

1. **상호 배제 (Mutual Exclusion)**: 프로세스 P1이 임계 구역에서 실행 중이라면, 다른 프로세스들은 임계 구역에 진입할 수 없음
2. **진행 (Progress)**: 임계 구역에서 실행 중인 프로세스가 없고 진입하려는 프로세스들이 있다면, 나머지 구역(Remainder Section)에서 실행 중이지 않은 프로세스들만 참여하여 누가 진입할지 결정해야 하며, 이 결정은 무한정 연기되어서는 안 됨 (데드락 방지)
3. **한정 대기 (Bounded Waiting)**: 프로세스가 진입 요청을 한 후 승인될 때까지 다른 프로세스들이 진입하는 횟수에 제한이 있어야 함 (기아 상태 방지)

---

## 3. 소프트웨어적 해결책: Peterson's Solution

두 개의 프로세스(P0, P1)에 한정된 고전적인 소프트웨어 기반 해결책으로, 다음 두 개의 변수를 사용하여 동기화를 실행한다.

- `turn`: 누구 차례인지
- `flag`: 진입 의사가 있는지

```cpp
while(true) {
  flag[i] = true;
  turn = j;
  while(flag[j] && turn == j)
    ;

    /* critical section */

  flag[i] = false;

   /* remainder section */
}
```

**한계**: 현대 컴퓨터 아키텍처에서는 성능 최적화를 위해 프로세서나 컴파일러가 명령어 순서를 재정렬(Instruction Reordering)할 수 있기 때문에, 피터슨 알고리즘이 항상 올바르게 작동한다는 보장을 하지 못한다.

---

## 4. 하드웨어적 지원

현대 시스템은 임계 구역(Critical Section) 보호를 위해 다음과 같은 하드웨어 명령어를 제공한다.

- **메모리 장벽 (Memory Barriers)**: 명령어 재정렬을 방지하여 메모리 변경 사항이 다른 프로세서에 즉시 보이도록 하는 명령어
- **하드웨어 명령어 (Atomic Instructions)**: 인터럽트 되지 않고 원자적(Atomic)으로 실행되는 명령어
  - `test_and_set()`: 값을 읽고 변경하는 것을 원자적으로 수행. 간단한 락 구현에 사용
  - `compare_and_swap()` (CAS): 변수의 값이 기대하는 값과 같을 때만 새로운 값으로 교체. 낙관적(Optimistic) 동기화 방식의 기초가 됨
- **원자적 변수 (Atomic Variables)**: 정수나 불리언 같은 기본 데이터 타입에 대해 원자적 연산(증가, 감소 등)을 보장하는 도구

### Atomic Variables 예시

```cpp
void increment(atomic_int *v){
  int temp;
  do{
    temp = *v;
  } while(temp != compare_and_swap(v, temp, temp+1));
}
```

---

## 5. 동기화 도구 (Synchronization Tools)

OS 설계자와 응용 프로그래머가 사용하는 상위 수준의 도구를 정리한다.

### 5-1. 뮤텍스 락 (Mutex Locks)

Mutual Exclusion(상호 배제)의 약자로, 임계 구역(Critical Section)을 보호하기 위한 가장 단순한 도구다.

#### 구현 방식 및 동작 원리

`available`이라는 불리언 변수를 사용하여 락의 가용 여부를 표시한다.

```c
acquire() {
    while (!available)
        ; /* busy wait: 락이 풀릴 때까지 무한 루프 */
    available = false; // 락 획득 (잠금)
}

release() {
    available = true;  // 락 반납 (해제)
}
```

- `acquire()`: 락이 사용 불가능(`!available`)하면 `while` 루프를 돌며 무한히 대기. 락이 풀리면 `available`을 `false`로 바꾸고 진입 (이 과정은 원자적으로 수행됨)
- `release()`: 볼 일을 마치고 `available`을 `true`로 설정하여 대기 중인 다른 프로세스가 진입할 수 있게 함

#### 핵심 특징: 스핀락 (Spinlock)

위의 `acquire()` 구현은 락을 얻을 때까지 루프를 계속 도는 바쁜 대기(Busy Waiting) 방식을 사용한다.

- **단점**: 대기하는 동안 CPU 사이클을 계속 소모하므로, 단일 코어 시스템이나 락을 오래 소유하는 경우 비효율적
- **장점**: 대기 상태로 전환될 때 문맥 교환(Context Switch)이 발생하지 않음. 따라서 멀티코어 시스템에서 락을 아주 짧게 소유하는 경우, 문맥 교환 비용을 아낄 수 있어 더 효율적

---

### 5-2. 세마포어 (Semaphores)

정수 변수 `S`를 사용하여 자원의 개수를 관리하는 정교한 도구다. 초기화 외에는 오직 `wait()`(P 연산)와 `signal()`(V 연산)이라는 원자적 연산으로만 접근 가능하다.

#### 구현 방식: 봉쇄형 (Blocking)

공룡책에서는 스핀락의 CPU 낭비를 막기 위해, 프로세스를 대기 큐(Waiting Queue)에 넣고 재우는(sleep) 방식을 제안한다.

**구조체 정의**

```c
typedef struct {
    int value;            // 자원의 개수 (또는 대기자 수)
    struct process *list; // 대기 중인 프로세스 리스트(큐)
} semaphore;
```

**wait(S) 연산 (자원 요청)**

```c
wait(semaphore *S) {
    S->value--;           // 1. 일단 자원 요청 (감소)
    if (S->value < 0) {   // 2. 자원이 모자라면 (음수)
        add this process to S->list; // 대기 리스트에 추가
        sleep();          // 프로세스를 재움 (CPU 반납)
    }
}
```

- 먼저 `value`를 감소시킴
- 감소시켰는데 음수가 되면 자원이 없다는 뜻이므로, 스스로를 대기 리스트에 넣고 `sleep()` 시스템 콜을 호출

**signal(S) 연산 (자원 반납)**

```c
signal(semaphore *S) {
    S->value++;           // 1. 자원 반납 (증가)
    if (S->value <= 0) {  // 2. 아직도 0 이하라면 (기다리는 사람이 있었다면)
        remove a process P from S->list; // 대기 리스트에서 꺼냄
        wakeup(P);        // 프로세스를 깨움
    }
}
```

- `value`를 증가시킴
- 증가시켰는데도 `value`가 0 이하라면, 내 자원을 기다리던 프로세스가 있었다는 뜻이므로 `wakeup()`을 호출하여 깨워줌

#### 세마포어 동작 상세 분석

이 구현의 핵심은 `value` 변수의 이중 의미를 이해하는 것이다.

- **양수 (+n)**: 현재 사용할 수 있는 빈 자원의 개수 (n개 남음)
- **음수 (-n)**: 자원이 다 떨어졌고, 현재 기다리고 있는 프로세스의 수 (n명 대기 중)

테이블이 2개인 식당 비유로 설명하면 (`initial value = 2`):

| 단계 | 상황 | value 변화 | 결과 |
|-----|------|-----------|------|
| 1 | P1 도착 | 2 → 1 | 바로 식사 시작 |
| 2 | P2 도착 | 1 → 0 | 마지막 자리 착석 (만석) |
| 3 | P3 도착 | 0 → -1 | 대기 1번, sleep() |
| 4 | P4 도착 | -1 → -2 | 대기 2번, sleep() |
| 5 | P1 퇴장 | -2 → -1 | P3 wakeup, 식사 시작 |
| 6 | P2 퇴장 | -1 → 0 | P4 wakeup, 식사 시작 |
| 7 | P3 퇴장 | 0 → 1 | 빈 자리 1개 발생 |

---

### 5-3. 모니터 (Monitors)

세마포어는 `wait`와 `signal`의 순서를 틀리는 등 프로그래머의 실수로 인한 타이밍 오류가 발생하기 쉽다. 모니터는 프로그래밍 언어 수준에서 제공하는 고수준 동기화 도구다 (예: 자바의 `synchronized`).

**특징:**

1. **자동 상호 배제**: 모니터 내부 함수는 한 번에 하나의 프로세스만 실행되도록 자동 제어됨
2. **조건 변수 (Condition Variables)**: 실행 순서 제어를 위해 `x.wait()`, `x.signal()`을 사용
   - `x.wait()`: 호출한 프로세스를 일시 중지하고 모니터 락을 반납
   - `x.signal()`: 대기 중인 프로세스 하나를 깨움 (없으면 아무 일도 안 함)

#### 예제: 식사하는 철학자 문제 (Deadlock 방지)

교재에서는 모니터를 사용해 데드락 없는 해결책을 제시한다. 핵심 아이디어는 양쪽 젓가락을 모두 사용할 수 있을 때만 집는 것이다.

주요 함수 로직:

1. `pickup(i)`: 젓가락 집기 시도 → 상태를 HUNGRY로 변경 → test(i) 호출 → 먹을 수 없다면 `self[i].wait()`로 대기
2. `putdown(i)`: 젓가락 내려놓기 → 상태를 THINKING으로 변경 → 양쪽 이웃에 대해 test() 호출
3. `test(i)`: (내가 HUNGRY) AND (왼쪽 != EATING) AND (오른쪽 != EATING) 조건 만족 시 EATING으로 변경하고 signal() 호출

> 이 방식은 교착 상태(Deadlock)는 막지만, 운 나쁜 철학자가 계속 밥을 못 먹는 기아 상태(Starvation)는 완벽히 해결하지 못할 수 있다.

---

### 동기화 도구 비교

| 특징 | Mutex | Semaphore | Spinlock |
|-----|-------|-----------|----------|
| 정의 | 잠금 메커니즘 | 신호 메커니즘 | 바쁜 대기를 하는 락 |
| 소유권 | 있음. 락을 획득한 스레드만 해제 가능 | 없음. 누구든지 signal() 가능 | 소유권 개념보다는 CPU 점유 여부가 중요 |
| 대기 방식 | 락을 못 얻으면 Sleep | 락(자원)이 없으면 Sleep (대기 큐 이동) | 락을 얻을 때까지 Loop (문맥 교환 없음) |
| 사용처 | 임계 구역 보호 (상호 배제) | 자원 관리, 프로세스 간 순서 제어 | 짧은 시간 동안 락을 보유할 때 (멀티코어 유리) |

교재에서는 뮤텍스를 설명할 때 스핀락이라는 구현 방식의 코드를 보여줬고, 세마포어를 설명할 때 슬립이라는 구현 방식의 코드를 보여준 것일 뿐, 핵심은 뮤텍스는 잠금(상호배제+소유권)/세마포어는 신호 기반의 동기화 방식이라는 점이다.

---

## 6. 라이브니스 (Liveness)

동기화 도구를 사용할 때 발생할 수 있는 진행 관련 문제를 정리한다.

- **데드락 (Deadlock)**: 두 개 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 무한정 대기하는 상태
- **우선순위 역전 (Priority Inversion)**: 낮은 우선순위 프로세스가 락을 잡고 있어서 높은 우선순위 프로세스가 실행되지 못하는 현상. 우선순위 상속(Priority Inheritance) 프로토콜로 해결

---

## 7. 평가 (Evaluation)

- **CAS vs 락**: 경합(Contention)이 적을 때는 CAS가 락보다 빠르지만, 경합이 매우 심할 때는 전통적인 락(대기 큐 사용)이 더 효율적일 수 있음
- 원자적 정수(Atomic Integer)는 카운터 갱신과 같은 단순 변수 업데이트에 있어 뮤텍스나 세마포어보다 훨씬 가볍고 빠름

---

## 마무리

다음 글에서는 이러한 OS 동기화 개념이 실제 DB(InnoDB, PostgreSQL)에서 어떻게 적용되는지, 그리고 DB-CAS 패턴이 내부적으로 어떻게 동작하는지 살펴본다.
