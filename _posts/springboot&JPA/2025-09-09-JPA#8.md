---
title: "[JPA]JPA 더티채킹"
excerpt: "SpringBoot&JPA#8"

categories:
  - JPA

date: 2025-09-09
last_modified_at: 2025-09-09
---

# JPA 더티 채킹이 뭐야

> JPA가 트랜잭션 커밋 시점에, <br>
> 영속성 컨텍스트 내부의 엔티티와 DB의 값을 비교해서 변경사항을 자동으로 감지하고 update 쿼리를 실행하는 기능

즉, 개발자가 update SQL을 명시적으로 쓰지 않아도, <br>
엔티티 객체의 값을 바꾸기만 하면 JPA가 알아서 변경을 감지하고 DB에 반영해준다

## 동작 과정 자세히 보기

### 1. 엔티티를 영속성 컨텍스트에 저장 (persist or 조회)

```java
Post post = postRepository.find(Post.class, 1L);
```

- 이 시점에서 post는 영속 상태가 되고,

- JPA는 내부적으로 스냅샷(초기 상태 복사본)을 저장한다!!
  -> 예시: { id: 1, title: "Hello", content: "World" }

### 2. 엔티티의 필드 변경

```java
post.setContent("Modified content");
```

- 단순히 post객체의 필드를 변경하는 Java코드

- 그래서 DB에 아무 쿼리도 날아가지 않는다

- 하지만 JPA는 이 post가 영속 상태인 걸 알고 있어서 트랜잭션 종료 전까지 변경 사항을 추적한다!

### 3. 트랜잭션 커밋 시점

```java
transaction.commit();
// 스프링에선 @Transactional 종료 시점
// 메서드에 @Transactional이 붙었다면 메서드가 끝나는 시점
```

📌 이때 JPA가 스냅샷 떠놓은 거랑 현재 상태를 비교함

```
스냅샷: content = "World"
현재: content = "Modified content"
→ 변경 감지
```

- → UPDATE post SET content = 'Modified content' WHERE id = 1 쿼리가 자동으로 생성되어 DB에 날려준다

🔎 핵심 키워드 정리

| 개념                       | 설명                                                          |
| :------------------------- | :------------------------------------------------------------ |
| 영속성 컨텍스트            | 엔티티를 관리하는 1차 캐시. 여기서 엔티티의 변경을 감지       |
| 스냅샷                     | 영속 상태가 된 엔티티의 필드 값 원본을 저장                   |
| 변경 감지 (Dirty Checking) | 트랜잭션 커밋 시 스냅샷과 현재 값을 비교하여 UPDATE 여부 결정 |
| flush                      | DB에 실제 쿼리를 날리는 시점 (커밋 시 자동으로 호출됨)        |

## 예시 코드

```java
@Transactional
public void updatePost(Long id, String newTitle) {
    Post post = postRepository.findById(id).orElseThrow();
    post.setTitle(newTitle);
    // 여기까지는 쿼리 안 날림

    // 트랜잭션 커밋되면 Dirty Checking → 자동 UPDATE
}
```

그래서 영속성이 필요한 메서드에 transactional을 붙여주면 영속성이 붙으며 JPA의 더티체킹도 이용할 수 있게되는 것임!

## update SQL이 안 날라가는 경우

### 1. 변경이 없으면 → update 없음

```java
post.setContent("World"); // 원래 값이랑 동일
// → Dirty Checking 감지 못함 → UPDATE 안됨
```

### 2. 엔티티가 영속 상태가 아닐 때

```java
Post post = new Post(); // 비영속 상태
post.setContent("New");

// persist 안 했고, find로 조회한 것도 아님
// → JPA가 관리하지 않음 → 더티체킹 없음
```

## flush()

- flush()는 영속성 컨텍스트의 변경 사항을 데이터베이스에 동기화만 함 (SQL 실행)
- 트랜잭션은 아직 종료되지 않음
- commit() 시점에 flush 자동 수행 + 실제 트랜잭션 커밋

flush() -> 변경사항 DB로 보냄(sql), 트랜잭션은 유지
<br>
commit() -> flush() + 트랜잭션 종료

```java
post.setTitle("변경");
postRepository.flush(); // 즉시 DB 반영되지만 트랜잭션은 계속 진행
```

### 강제로 flush 시점 제어

- Repository.flush()
- saveAndFlush() (Spring Data JPA)
- @Transactional(propagation = Propagation.REQUIRES_NEW) 로 분리 트랜잭션 사용

## 정리

더티체킹: <br>
JPA가 트랜잭션 커밋 시점에 영속성 컨텍스트에 있는 엔티티 객체의 변경 여부를 감지(Dirt Check) 해서, 변경된 필드만 바탕으로 UPDATE SQL을 자동 생성해 DB에 반영하는 기능

작동 흐름<br/> 1. 트랜잭션 시작 (@Transactional) <br/> 2. find() 또는 save() 등을 통해 엔티티 영속화 <br/> 3. 자바 코드에서 엔티티 필드 수정 (post.setTitle("바뀐 제목"))<br/> 4. 트랜잭션 커밋 시점 <br/> 5. JPA 내부에서는 스냅샷(초기 상태) 과 현재 상태를 비교 <br/> 6. 변경된 필드만 UPDATE 쿼리에 포함시킴 <br/>

## 더티 체킹 성능 이슈

1. 모든 필드 비교
  - JPA는 flush()나 commit() 시점에 영속성 컨텍스트에 있는 모든 엔티티의 스냅샷을 비교 → 비교 연산 비용 발생
  - 성능에 민감한 대규모 시스템에서는 부하 요인이 될 수 있음
2. 불필요한 UPDATE 발생 가능성
  - @Setter 남용 등으로 실제 값이 변하지 않았지만 setter 호출만으로도 더티 체킹 트리거 가능
  - 특히 이 경우 DB-level에서 보기엔 아무 변화도 없는 UPDATE가 날아가게 됨 → Lock 경합, 트랜잭션 충돌, 쓰기 부하 초래

### 불필요한 update?

```java
@PostMapping("/posts/{id}")
public String updatePost(@PathVariable Long id, PostDto dto) {
    Post post = postRepository.findById(id).get();

    // 이 두 개 모두 기존 값과 같음
    post.setTitle(dto.getTitle());
    post.setContent(dto.getContent());

    // 하지만 setter를 호출했기 때문에 변경 감지가 발생할 수도 있음!
    // → 실제로는 안 바뀌었는데 UPDATE 쿼리 날라감
}
```

변경은 없는 setter를 말하는거임 -> 그럼에도 더티 체킹이 트리거되서 불푤요한 update쿼리가 발생한다

### 구체적인 성능 저하

1. DB 락 경합 (Lock Contention)
  - 불필요한 UPDATE도 결국은 트랜잭션이므로, 해당 row에 락이 걸림
  - 동시에 누군가가 해당 row를 수정하려고 하면 충돌(Rollback, 대기 등)이 발생할 수 있음
2. 쓰기 부하 증가 (Write Pressure)
  - 변경이 없는 row도 UPDATE 되므로,
  - 변경 로그, WAL(Write-Ahead Log), Redo log가 쌓임
  - RDB의 I/O 처리량이 커지고 성능이 나빠짐
3. 불필요한 트리거, 히스토리 로그 작동
  - DB에 트리거 걸려 있으면 작동
  - 변경감지 시스템이 있으면 “가짜 변경”이 기록됨

## 최적화 방법 - 1. @DynamicUpdate

- Hibernate 전용 어노테이션
- 실제로 변경된 필드만 UPDATE 쿼리에 포함시켜줌
- 기본 JPA 동작은 “모든 컬럼”이 SQL에 포함되기 때문에 이를 보완

```java
@Entity
@DynamicUpdate
public class Post {
    ...
}
```

아래와 같은 차이가 발생함

- 일반 JPA:

  ```sql
  UPDATE post SET title=?, content=?, updated_at=? WHERE  id=?
  ```

- DynamicUpdate:

  ```sql
  UPDATE post SET title=? WHERE id=?
  ```

단, @DynamicUpdate는 런타임에 동적으로 SQL을 만들기 때문에 캐시 비효율이 있을 수 있어서 남용❌

## 최적화 - 2. 변경 감지를 피하고 명시적으로 쿼리 실행

변경 감지 대신 JPQL이나 QueryDsl로 직접 UPDATE 구문을 날리면 비교를 생략할 수 있음

```java
@Modifying
@Query("UPDATE Post p SET p.title = :title WHERE p.id = :id")
void updateTitle(@Param("id") Long id, @Param("title") String title);
```

- 장점: 더티 체킹 X → 성능 좋음
- 단점: 영속성 컨텍스트와 불일치 상태 주의(1차 캐시)
