---
title: "[JPA]SpringBoot&JPA#9"
excerpt: "연관관계 매핑"

categories:
  - JPA

date: 2025-09-09
last_modified_at: 2025-09-09
---

# 연관관계 매핑

> 객체의 참조와 테이블의 외래 키를 매핑하는 것

방향에는 단방향과 양방향이 있다
- 단방향 관계
  - 두 엔티티가 관계를 맺을 때, 한 쪽의 엔티티만 참조하고 있는 것
  - 참조를 가지고 있는 엔티티만 매핑 관계를 알 수 있다

- 양방향 관계
  - 두 엔티티가 관계를 맺을 때, 양 쪽이 서로 참조

# @OneToOne (1:1관계)

```java
@Entity
public class User {
    @OneToOne
    @JoinColumn(name = "passport_id")
    private Passport passport;
}
```
-	주 테이블이 외래키를 가짐 (@JoinColumn 사용)
-	기본은 즉시 로딩(EAGER)
-	mappedBy 사용 시 양방향 매핑 가능

# @OneToMany (1:N관계)

```java
@Entity
public class Post {
    @OneToMany(mappedBy = "post")
    private List<Comment> commentList;
}
```
-	성능상 반드시 양방향 매핑으로 작성하는 걸 권장
-	mappedBy는 자식 쪽 필드 이름을 가리킴

# @ManyToOne(N:1관계)
```java
@Entity
public class Comment {
    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;
}
```
-	가장 자주 사용되는 연관관계
-	N개의 댓글이 1개의 게시글을 가리킴
-	@JoinColumn이 외래 키 설정

## @JoinColumn 생략

해당 어노테이션은 생략 가능하다<br/>
생략하면 -> 외래키를 찾을 때 기본 전략을 사용한다 

- 기본전략: 필드명 + _ + 참조하는 테이블의 컬럼명
- post(필드명) + _ + id(참조하는 테이블 컬럼명)<br/>
-> post_id

# @ManyToMany (N:N관계)
```java
@Entity
public class Student {
    @ManyToMany
    @JoinTable(
        name = "student_class",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "class_id")
    )
    private List<Class> classes;
}
```
-	주의: 실무에서는 거의 사용하지 않음
-	대신, 중간 테이블(매핑 테이블)을 엔티티로 분리해서 @OneToMany + @ManyToOne으로 처리

# 양방향 연관관계

post-comment관계에서 양방향 매핑으로, 데이터베이스 테이블은 외래 키가 주입되어 양방향으로 조회가 가능해진다.

## 엔티티의 매핑

> `테이블`은 외래 키 하나로 두 테이블의 연관관계를 관리한다<br/>
> 한쪽에만 매핑해주면 키 하나로 조인해서 양방향 매핑이 가능하지만

> `엔티티`에서는, 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나가되어 둘 사이에 차이가 발생하게 된다.

> JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리하는데 이것을 연관관계의 주인(Owner)이라 한다.

## 연관관계 주인

[![image.png](https://i.postimg.cc/x8p13Dcx/image.png)](https://postimg.cc/K3LbmW7B)

- 연관관계의 주인을 설정함으로서 외래 키 관리자를 선택하게 된다.
- Member가 가지고 있는 team이 주인
- Team이 가지고 있는 member리스트는 mappedby로 관리된다.
- 데이터베이스 다디일 관계에서 "다"쪽이 외래키를 가지게 된다.

### 양방향 매핑 주의점

무한루프!

- Member.toString()에서 getTeam()을 호출하고
- Team.toString()에서 getMember()를 호출하면 무한루프에 빠짐
- 특히 엔티티를 JSON으로 변환할 떄 자주 발생하며 이를 방지해주는 lombok어노테이션을 사용하면 해결 가능하다. 

```java
@Entity
public class Member {
    @ManyToOne
    @JsonIgnore
    private Team team;
}
```

# 코드

```java
@ManyToOne
private Question question;
```
```java
@OneToMany(mappedBy = "question", fetch=FetchType.LAZY, cascade = {CascadeType.REMOVE,  CascadeType.PERSIST})
private List<Answer> answerList;
```

# 1:N 관계

하나의 Question이 여러 개의 Answer를 가지는 구조임

## 필드별 설명

### 1. mappedBy = "question"
  -	연관관계의 주인이 아닌 쪽에서 사용하는 속성입니다.
  -	"question"은 Answer 클래스의 필드명으로, @ManyToOne으로 지정된 필드입니다.
  - Answer클래스의 qustion 필드를 참조하게 된다
  - mappedBy를 지정하지 않으면 양쪽 모두 외래키를 관리하려고 해서 JPA가 예외를 던지거나 중복 컬럼을 생성할 수 있습니다.

### 2. fetch = FetchType.LAZY

- 연관된 데이터를 언제 로딩할지 결정하는 전략

- LAZY (지연 로딩): 실제 사용할 때까지 DB 조회를 미룸 (answerList.get(0) 등으로 접근할 때 조회)

- EAGER (즉시 로딩): Question을 조회할 때 Answer도 같이 조회함 (즉시 JOIN)

### 3. cascade

| 옵션 | 설명 |
|:----|:----|
| PERSIST | 부모 저장 시 자식도 같이 저장 |
| REMOVE | 부모 삭제 시 자식도 같이 삭제 |
| MERGE | 병합 시 같이 병합 (entityManager.merge()) |
| DETACH | 분리 시 같이 분리 |
| REFRESH | DB에서 다시 로드할 때 같이 새로 고침 |
| ALL | 위의 모든 동작 포함 (PERSIST, MERGE, REMOVE, REFRESH, DETACH) |

### 4. orphanRemoval = true (선택 속성)

-	List에서 자식 엔티티를 제거하면, DB에서도 자동으로 삭제됨.

```java
question.getAnswerList().remove(answer); // DB에서도 answer 삭제됨
```

- cascade = REMOVE와 함께 사용하면 효과적