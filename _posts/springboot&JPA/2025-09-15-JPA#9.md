---
title: "[JPA]연관관계 매핑"
date: 2025-09-15 09:00:00 +0900
categories: [Spring]
tags: [java, jpa, spring, backend]
---
# 연관관계 매핑

> 객체의 참조와 테이블의 외래 키를 매핑하는 것

방향에는 단방향과 양방향이 있다
- 단방향 관계
  - 두 엔티티가 관계를 맺을 때, 한 쪽의 엔티티만 참조하고 있는 것
  - 참조를 가지고 있는 엔티티만 매핑 관계를 알 수 있다

- 양방향 관계
  - 두 엔티티가 관계를 맺을 때, 양 쪽이 서로 참조

# @OneToOne (1:1관계)

```java
@Entity
public class User {
    @OneToOne
    @JoinColumn(name = "passport_id")
    private Passport passport;
}
```
-	주 테이블이 외래키를 가짐 (@JoinColumn 사용)
-	기본은 즉시 로딩(EAGER)
-	mappedBy 사용 시 양방향 매핑 가능

# @OneToMany (1:N관계)

```java
@Entity
public class Post {
    @OneToMany(mappedBy = "post")
    private List<Comment> commentList;
}
```
-	성능상 반드시 양방향 매핑으로 작성하는 걸 권장
-	mappedBy는 자식 쪽 필드 이름을 가리킴

# @ManyToOne(N:1관계)
```java
@Entity
public class Comment {
    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;
}
```
-	가장 자주 사용되는 연관관계
-	N개의 댓글이 1개의 게시글을 가리킴
-	@JoinColumn이 외래 키 설정

## @JoinColumn 생략

해당 어노테이션은 생략 가능하다<br/>
생략하면 -> 외래키를 찾을 때 기본 전략을 사용한다 

- 기본전략: 필드명 + _ + 참조하는 테이블의 컬럼명
- post(필드명) + _ + id(참조하는 테이블 컬럼명)<br/>
-> post_id

# @ManyToMany (N:N관계)
```java
@Entity
public class Student {
    @ManyToMany
    @JoinTable(
        name = "student_class",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "class_id")
    )
    private List<Class> classes;
}
```
-	주의: 실무에서는 거의 사용하지 않음
-	대신, 중간 테이블(매핑 테이블)을 엔티티로 분리해서 @OneToMany + @ManyToOne으로 처리

# 양방향 연관관계

post-comment관계에서 양방향 매핑으로, 데이터베이스 테이블은 외래 키가 주입되어 양방향으로 조회가 가능해진다.

## 엔티티의 매핑

> `테이블`은 외래 키 하나로 두 테이블의 연관관계를 관리한다<br/>
> 한쪽에만 매핑해주면 키 하나로 조인해서 양방향 매핑이 가능하지만

> `엔티티`에서는, 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나가되어 둘 사이에 차이가 발생하게 된다.

> JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리하는데 이것을 연관관계의 주인(Owner)이라 한다.

## 연관관계 주인

[![image.png](https://i.postimg.cc/x8p13Dcx/image.png)](https://postimg.cc/K3LbmW7B)

- 연관관계의 주인을 설정함으로서 외래 키 관리자를 선택하게 된다.
- Member가 가지고 있는 team이 주인
- Team이 가지고 있는 member리스트는 mappedby로 관리된다.
- 데이터베이스 다디일 관계에서 "다"쪽이 외래키를 가지게 된다.

### 양방향 매핑 주의점

무한루프!

- Member.toString()에서 getTeam()을 호출하고
- Team.toString()에서 getMember()를 호출하면 무한루프에 빠짐
- 특히 엔티티를 JSON으로 변환할 떄 자주 발생하며 이를 방지해주는 lombok어노테이션을 사용하면 해결 가능하다. 

```java
@Entity
public class Member {
    @ManyToOne
    @JsonIgnore
    private Team team;
}
```

# 코드

```java
@ManyToOne
private Question question;
```
```java
@OneToMany(mappedBy = "question", fetch=FetchType.LAZY, cascade = {CascadeType.REMOVE,  CascadeType.PERSIST})
private List<Answer> answerList;
```

# 1:N 관계

하나의 Question이 여러 개의 Answer를 가지는 구조임

## 필드별 설명

### 1. mappedBy = "question"
  -	연관관계의 주인이 아닌 쪽에서 사용하는 속성입니다.
  -	"question"은 Answer 클래스의 필드명으로, @ManyToOne으로 지정된 필드입니다.
  - Answer클래스의 qustion 필드를 참조하게 된다
  - mappedBy를 지정하지 않으면 양쪽 모두 외래키를 관리하려고 해서 JPA가 예외를 던지거나 중복 컬럼을 생성할 수 있습니다.

### 2. fetch = FetchType.LAZY

- 연관된 데이터를 언제 로딩할지 결정하는 전략

- LAZY (지연 로딩): 실제 사용할 때까지 DB 조회를 미룸 (answerList.get(0) 등으로 접근할 때 조회)

- EAGER (즉시 로딩): Question을 조회할 때 Answer도 같이 조회함 (즉시 JOIN)

### 3. cascade

| 옵션 | 설명 |
|:----|:----|
| PERSIST | 부모 저장 시 자식도 같이 저장 |
| REMOVE | 부모 삭제 시 자식도 같이 삭제 |
| MERGE | 병합 시 같이 병합 (entityManager.merge()) |
| DETACH | 분리 시 같이 분리 |
| REFRESH | DB에서 다시 로드할 때 같이 새로 고침 |
| ALL | 위의 모든 동작 포함 (PERSIST, MERGE, REMOVE, REFRESH, DETACH) |

### 4. orphanRemoval = true (선택 속성)

-	List에서 자식 엔티티를 제거하면, DB에서도 자동으로 삭제됨.

```java
question.getAnswerList().remove(answer); // DB에서도 answer 삭제됨
```

- cascade = REMOVE와 함께 사용하면 효과적


# 객체 초기화

```java
@Configuration
@RequiredArgsConstructor
public class BaseInitData {

    @Autowired
    @Lazy
    private BaseInitData self;
    private final QuestionRepository questionRepository;

    @Bean
    ApplicationRunner initDataRunner() {
        return args -> {
            self.work1();
        };
    }

    @Transactional
    void work1(){
        ...

        Question q2 = new Question();
        q2.addAnswer("네 자동으로 생성됩니다.");
        questionRepository.save(q2);  // 두번째 질문 저장
    }
}
```

Question.java
```java
@OneToMany(mappedBy = "question", fetch=FetchType.LAZY, cascade = {CascadeType.REMOVE,  CascadeType.PERSIST})
private List<Answer> answerList;
```

Answer.java
```java
@ManyToOne
private Question question;
```

## 위와 같이 세팅하고 앱을 실행하면 NPE발생함

> question에 있는 answerList가 null상태일 수도 있어서 에러 발생시킴

- JPA는 영속화 이전의 객체 생성 시점에서는 필드 초기화를 어케하든 상관안함

- null상태를 방지하기 위해 컬렉션 필드는 항상 초기화해주는 것이 권장됨.

- JPA는 이 컬렉션을 내부적으로 하이버네이트의 프록시 컬렉션으로 교체
- 초기화된 컬렉션은 JPA가 나중에 무시하거나 덮어써도 문제 없음
- 초기화는 안전장치가 된다.

## JPA가 리스트에 Answer를 영속화해서 add하려면 new해줘야 하는거 아닌가?

> new Answer()는 개발자가 해줘야하는 거임</br>
> 그 후 List.add(answer)처럼 연관관계를 명시적으로 설정해줘야 JPA가 관계를 인식함

### JPA는 객체의 생성까지 자동으로 해주지 않는다.

다음만 자동으로 함

| 기능 | 설명 |
|:----|:----|
| @OneToMany, @ManyToOne | 객체 간 참조를 기반으로 외래 키 연관관계를 매핑 |
| @Cascade(PERSIST) | 부모가 persist 될 때 자식도 persist 되도록 허용 |
| flush() 시점 | 변경 감지 후 INSERT/UPDATE SQL 실행 |

하지만 객체 생성은 개발자 몫임
- 사실 생각해보면 당연하다.
- JPA는 @OneToMany, @ManyToOne으로 테이블 관계를 매핑만 해줄 뿐,
- 실제 객체를 new해서 넣어주거나 List에 add() 해주는 건 전적으로 개발자의 책임

### question.addAnswer()는 그 연결을 자동화하는 메서드
-	JPA는 연관관계 주인(Answer.question)만 보고 DB에 foreign key를 설정
-	반대편(Question.answerList)만 설정하면 DB 반영되지 않음
-	따라서 addAnswer()로 양방향 모두 설정해야 논리적으로 연결 + DB 저장 둘 다 확보

### List또한 null로 넘어올 수 있는 상황을 개발자가 방지해줘야 한다.


## 결론: 해결책
아래와 같이 선언 시 초기화, 또는 생성자 초기화를 해줘야 안전하게 JPA에 넘어감
```java
private List<Answer> answerList = new ArrayList<>();
```