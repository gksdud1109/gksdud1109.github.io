---
title: "[JPA]SpringBoot&JPA#5"
excerpt: ""

categories:
  - JPA

date: 2025-09-08"
last_modified_at: 2025-09-08"
---

# @Autowired

- 스프링의 의존성 주입(DI)을 위한 어노테이션
- 스프링 컨테이너가 관리하는 빈을 자동으로 주입받을 수 있게 해준다.
- 생성자, 필드, 메서드에 사용할 수 있다
- 생성자 주입이 가장 권장되는 방식이다

- 필드 주입은 테스트가 어렵고 순환 참조 문제가 발생할 수 있어 지양된다.

### 순환참조

- A클래스가 B클래스를 의존하고, B클래스도 A클래스를 의존하는 상황
- 서로가 서로를 필요로 해서 스프링이 빈을 생성할 수 없다.

```java
@Component
public class A {

    @Autowired
    private B b;

    public void doSomething() {
        System.out.println("A is doing something");
    }
}
```

```java
@Component
public class B {

    @Autowired
    private A a;

    public void doSomething() {
        System.out.println("B is doing something");
    }
}
```

- 두 클래스가 서로를 필드로 의존하는 상황,
- 무한루프처럼 서로를 요구해서 BeanCurrentlyInCreationException예외가 발생한다
- 좀 로맨틱 하네요...

### 생성자 주입

```java
@Component
public class A {
    private final B b;

    public A(B b) {
        this.b = b;
    }
}
```

```java
@Component
public class B {
    private final A a;

    public B(A a) {
        this.a = a;
    }
}
```

- 위 코드도 순환 참조이고 최신 스프링에서는 순환 참조 자체가 금지
- 하지만 명시적으로 설정(spring.main.allow-circular-references=true)을 하면 Spring이 ObjectFactory, 프록시, 지연 초기화 등을 활용해 순환을 해결할 수 있음

> 💡 필드 주입이 더 위험한 이유
>
> - 객체 생성과 DI가 분리되어 있어 순환을 깨는 시점이 애매함
> - 테스트나 명시적 주입이 불가능 → mock 주입 어려움
> - 생성자처럼 초기화 단계에서 순환을 조정할 수 있는 여지가 없음

# @Entity

```java
@Entity
@Setter
@Getter
@RequiredArgsConstructor
public class Post {

    @Id
    @GeneratedValue(strategy = jakarta.persistence.GenerationType.IDENTITY)
    private int id;
    private final String title;
    @Column(columnDefinition = "TEXT")
    private final String content;

    public Post() {
        this.title = "";
        this.content = "";
    }
}
```

- @Entity는 JPA가 관리하는 엔티티(테이블 매핑 대상)임을 명시하는 어노테이션
- JPA가 DB테이블로 매핑할 준비를 하고 이에 따라 반드시 @Id(기본키)를 가져야 한다

  - 없다면 javax.persistence.PersistenceException 예외 발생

- @Getter, @Setter는 Lombok의 어노테이션으로 모든 필드에 대한 게터세터를 자동 생성해준다

- @RequiredArgsConstructor
  </br> → final 필드를 인자로 받는 생성자를 생성함.
  즉, title과 content를 매개로 받는 생성자가 생성됨.

- 하지만 final로 선언시 변경을 못하므로 저렇게 선언하면 안된다.
- id의 경우엔 변경할 일이 없기 때문에 final로 해도 되지만, 간결한 코드를 위해 생략하는 경우가 많음

## JPA Entity 테이블 매핑 어노테이션들

### @Entity

- jpa가 관리할 수 있는 클래스임을 나타냄 -> DB테이블과 매핑
- 해당 클래스는 기본 생성자 필수, @Id 필드 필수

<hr>

### @Table

- 매핑될 테이블 이름이나 ddl옵션을 명시

```java
@Entity
@Table(name = "posts", uniqueConstraints = @UniqueConstraint(columnNames = {"title"}))
```

- name: 매핑할 테이블 이름
- schema: 사용할 DB스키마 이름
- uniqueConstraints: 유니크 제약 조건 설정

<hr>

### @Id

- 기본 키(PK)를 나타냄. 반드시 하나 필요

<hr>

### @GeneratedValue

- 기본 키 값 자동 생성 전략 설정

[JPA 기본키 생성 전략, @GeneratedValue 사용시 주의점](https://devcamus.tistory.com/16)

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
```

#### 전략

- IDENTITY: 기본 키 생성을 db에 위임 -> mysql의 경우 auto_increment 전략을 사용한다
- SEQUENCE: db시퀸스 사용 -> db시퀸스는 유일한 값을 순서대로 생성하는 특별한 오브젝트(ex. 오라클 시퀸스)
- TABLE: 키 생성 전용 테이블을 하나 만들어서 db시퀸스를 흉내내는 전략 -> 성능적으로 구림
- AUTO: hibernate.dialect에 설정된 db방언 종류에 따라, 하이버네이트가 자동으로 전략을 선택하게끔 위임 -> 글에 나와 있듯이 잘모르고 사용하면 위험❌

<hr>

### @Column

- 필드를 컬럼과 매핑하고 상세 설정 가능

```java
@Column(name = "title", nullable = false, unique = true, length = 100)
```

- name: db칼럼 이름
- nullable: NOT NULL 여부
- length: 문자열 길이 제한(기본 255)
- unique: 유니크 제약조건
- columnDefinition: db데이터 타입 직접 명시(ex. "TEXT", "varchar(100 default 'Y'"))

<hr>

### @Lob

- 대용량 데이터(텍스트나 바이너리) 저장용
- @Column(columnDefinition = "TEXT")의 대안

<hr>

### @Enumerated

- enum타입을 db에 어떻게 저장할지 결정

```java
@Enumerated(EnumType.STRING)
private PostStatus status;
```

- ORDINAL(스펠링 틀린거 아님): enum의 순서를 숫자로 저장 -> enum타입 변경시 숫자 대응이 틀릴 위험❌
- STRING: enum 이름을 문자열로 저장

<hr>

### @CreationTimestamp / @UpdateTimestamp

- Hibernate가 제공(JPA ❌)
- 자동으로 생성/수정 시간 저장

```java
@CreationTimestamp
private LocalDateTime createdAt;

@UpdateTimestamp
private LocalDateTime updatedAt;
```

<hr>

### @Transient

- db에 저장하지 않을 필드 지정(ex. 계산값, DTO 변환용 등)

```java
@Transient
private String notSavedField;
```

<hr>

### @Embeddable / @Embedded

- 값 타입 객체를 테이블에 함꼐 저장할 떄 사용 (ex. 주소, 이름 등 복합 값)

```java
@Embeddable
public class Address {
    private String city;
    private String street;
}

@Embedded
private Address address;
```

- Embeddable: 값 타입을 정의하는 곳
- Embedded: 값 타입을 사용하는 곳
- 임베드 타입은 기본 생성자가 필수임

<hr>

### @MappedSuperclass

- 공통 필드만 정의한 부모 클래스에서 사용
- 실제 테이블은 생성되지 않음

```java
@MappedSuperclass
public abstract class BaseEntity {
    @CreatedDate
    private LocalDateTime createdAt;
}
```

<hr>

### @Access

- jpa가 필드 또는 getter/setter 기준으로 접근할지 설정

```java
@Access(AccessType.FIELD)
private String title;
```

## 최종 변경된 post객체

```java
@Entity
@Setter
@Getter
@NoArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class Post {

    @Id
    @GeneratedValue(strategy = jakarta.persistence.GenerationType.IDENTITY)
    private int id;
    private String title;
    @Column(columnDefinition = "TEXT")
    private String content;

    @CreatedDate
    private LocalDateTime createDate;

    @LastModifiedDate
    private LocalDateTime modifyDate;

    public Post(String title, String content) {
        this.title = title;
        this.content = content;
    }
}
```

```java
@SpringBootApplication
@EnableJpaAuditing
public class DemoApplication {
  ...
}
```

- 여기에 @EnableJpaAuditing을 붙여줘야 @CreatedDate/@LastModifiedDate 어노테이션이 제대로 동작

- [JPA - Auditing 튜토리얼](https://docs.spring.io/spring-data/jpa/reference/auditing.html)
