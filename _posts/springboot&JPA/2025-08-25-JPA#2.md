---
title: "[JPA]yml설정, 엔티티 클래스"
excerpt: "SpringBoot&JPA#2"

categories:
  - JPA

date: 2025-08-25
last_modified_at: 2025-08-25
---

## Application.yml 설정

```yml
server:
  port: 8070

spring:
  application:
    name: demo

  datasource:
    url: jdbc:h2:./db_dev;MODE=MySQL
    username: sa
    password:
    driver-class-name: org.h2.Driver

  jpa:
    hibernate:
      ddl-auto: create
    show-sql: true
```

### 1. 내장 톰캣 서버가 실행될 포트를 8070으로 지정
- 기본은 8080이지만 충돌을 피하거나 구분을 위해 변경

### 2. spring.application.name: demo

- 애플리케이션 이름 지정
- 로깅이나 Spring Cloud에서 주로 사용됨

### 3. spring.datasource.url: jdbc:h2:./db_dev;MODE=MySQL

> 데이터베이스 연결 URL 설정

- jdbc:h2: => H2 DB사용
- ./db_dev => 현재 프로젝트 디렉토리에 db_dev.mv.db파일 생성됨(파일 기반 H2 DB)
- MODE=MYSQL => H2가 MySQL과 문법 호환되도록 작동하게 설정
  </br>(예: LIMIT, AUTO_INCREMENT, 백틱 사용 등)
- 주의할 점은 H2 콘솔에서도 이 URL 그대로 입력해야 접속 가능함

### 4. spring.datasource.username: sa / password:

> DB 접속 계정

- H2 기본 계정: sa (System Admin)
- 비밀번호는 기본적으로 없음 (""로 처리됨)

### 5. spring.datasource.driver-class-name: org.h2.Driver

> JDBC 드라이버 지정

- H2 전용 드라이버
- 사실 Spring Boot는 URL을 통해 자동으로 인식 가능하므로 생략해도 무방함

### 6. spring.jpa.hibernate.ddl-auto: create

> JPA -> DB로 테이블 자동 생성할 때 전략 지정

| 값          | 설명                                              |
| :---------- | :------------------------------------------------ |
| none        | 아무 작업 안 함 (기본값)                          |
| validate    | DB 테이블이 JPA 엔티티 구조와 맞는지 검증만 함    |
| update      | 기존 테이블은 유지하고 필요한 컬럼만 추가         |
| create      | 매번 애플리케이션 실행 시 모든 테이블을 새로 생성 |
| create-drop | 애플리케이션 종료 시 테이블 삭제까지 수행         |

- ⚠️ create는 실무에서는 절대 사용하지 말고, 테스트/개발 단계에서만 사용하세요.</br>
  → 실행할 때마다 기존 테이블이 모두 삭제되고 새로 만들어지기 때문이에요.

### 7. spring.jpa.show-sql: true

> JPA가 실행하는 SQL 쿼리를 콘솔에 출력

- 예: Hibernate: create table ..., select \* from ... 등
- 디버깅과 학습에 매우 유용한 옵션

### DB 연결 정보가 없어도 스프링부트 실행중에 오류가 발생하지 않는 이유

- Spring Data JPA는 데이터베이스와의 연결이 필수적이기 때문에 일반적으로 DB 연결 정보(URL, 사용자명, 비밀번호 등)를 명시해야함

- 하지만 H2는 인메모리 데이터 베이스로 Spring Boot에서 기본 설정값을 제공하기 때문에 따로 연결정보를 설정하지 않아도 자동으로 동작함

### .gitignore의 역할

- Git이 추적하지 않아야 할 파일들을 지정하는 설정 파일
  - 민감한 정보가 포함된 파일(비밀번호, API 키 등)을 Git 저장소에 포함시키지 않는다
  - 빌드 결과물, 로그파일, 임시파일 등 불필요한 파일들도 제외
  - IDE나 에디터에서 생성하는 설정 파일들을 제외
  - DB파일(이 프로젝트에서는 db_dev.mv.db, db_dev.trace.db)와 같은 로컬 개발환경 파일들도 제외시킴

## H2 client 접속

- h2 console 접속 - http://localhost:8070/h2-console
- Driver Class : org.h2.Driver
- JDBC URL : jdbc:h2:./db_dev;MODE=MySQL
- User Name : sa
- Password : [없음] <- 설정 안했음

[![2025-08-25-22-30-55.png](https://i.postimg.cc/mrYZs16d/2025-08-25-22-30-55.png)](https://postimg.cc/hJGR8vnx)

- 서버 실행하고 -> 콘솔 접속 -> connect하면 DB콘솔 조작 가능

## 엔티티 클래스

> JPA 엔티티 클래스는 DB테이블 구조를 정의하는 자바 클래스
> </br> 테이블의 스키마를 코드로 모델링한 것

- 기본 구성 요소
  - @Entity: 이 클래스가 JPA 관리 대상임을 표시
  - @Table(선택): 매핑될 테이블명을 명시 (기본은 클래스명과 동일)
  - 필드: 테이블의 컬럼에 대응, private 권장
  - @Column(선택): 컬럼 속성 명시 (이름, 길이, null 허용 여부 등)
  - @Id: 기본키(PK) 지정 – 필수
  - @GeneratedValue: 기본키의 생성 전략 설정 (AUTO, IDENTITY 등)
  - 기본 생성자: 반드시 있어야 함 (public 또는 protected)

### 주의할 사항

- 엔티티 ≠ 테이블
  - 엔티티는 테이블 구조를 정의,
  - 테이블은 데이터(ROW) 를 저장
- 엔티티 객체 1개 = 테이블의 ROW 1개
- 엔티티 클래스는 final로 선언 ❌
- Getter/Setter는 필수는 아니지만, 관례상 사용 (Lombok으로 자동 생성 가능)

### 예시 코드

```java
package com.back.domain.post.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@Entity
@NoArgsConstructor
public class Post {

    @Id
    @GeneratedValue(strategy = jakarta.persistence.GenerationType.IDENTITY)
    private int id;
    private String title;

    @Column(columnDefinition = "TEXT")
    private String content;
    private LocalDateTime createTime;
    private LocalDateTime modifyTime;

    public Post(String title, String content) {
        this.title = title;
        this.content = content;
        this.createTime = LocalDateTime.now();
        this.modifyTime = LocalDateTime.now();
    }
}
```

### jakarta.persistence vs javax.persistence

> JPA 어노테이션의 “패키지 명칭” 차이인데, 단순한 코드 스타일의 차이가 아니라 JPA의 역사와 버전 변화와 직접 관련이 있음

| 항목                | javax.persistence.\*   | jakarta.persistence.\*      |
| :------------------ | :--------------------- | :-------------------------- |
| JPA 버전            | JPA 2.x (예전)         | JPA 3.0 이상 (최신)         |
| 자바 EE 시대 패키지 | javax (Java Extension) | jakarta (Eclipse 재단)      |
| Spring Boot 호환성  | 2.x 버전대             | 3.x부터는 jakarta만 지원    |
| 호환 여부           | 일부 가능 (구버전)     | Spring Boot 3 이상에선 필수 |

> 바뀐 이유: </br>
>
> - 과거: JPA는 Java EE의 일부였고, 모든 어노테이션이 javax.persistence 아래에 있었음</br>
> - 2020년: Java EE가 Eclipse 재단에 이관되면서 ‘Jakarta EE’로 개명</br>
> - 이후부터는 javax.persistence → jakarta.persistence 로 강제 변경됨</br>
> - JPA 3.0 (2022년~): jakarta.persistence가 공식 표준

- spring boot 2.x -> javax.persistence.\*
- Spring Boot 3.x 이상 or Hibernate 6.x이상, 최신 JPA -> 모두 jakarta에 맞춤

#### 결론: 아무튼 최신 버전에서는 jakarta만 쓰면 된다.

> 💡혼용하면 안되는 이유: javax와 jakarta는 서로 다른 패키지라서, </br>
> 일부 라이브러리는 jakarta만 인식하고 javax는 무시함 → 매핑 실패/런타임 에러 발생 가능

### ddl-auto: update

create -> 기존 테이블을 삭제하고 새로 생성 -> DB가 매번 초기화됨

- 앱 실행 시 기존 테이블이 있으면 모두 DROP
- 그 후에 엔티티 기준으로 테이블 새로 생성
- 모든 테이블이 새로 만들어지므로, 기존 데이터 모두 삭제됨

update -> 기존 테이블을 유지하고 필요한 컬럼만 추가/수정 -> 데이터 보존됨

- 엔티티와 비교하여 변경된 컬럼이나 테이블만 자동 반영
- 기존에 있던 데이터는 지워지지 않음
- 컬럼 삭제, 제약 조건 변경 등 복잡한 변경은 안됨 (직접 쿼리 필요)
