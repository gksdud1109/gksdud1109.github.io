---
title: "[JPA]@Transaction"
excerpt: "SpringBoot&JPA#6"

categories:
  - JPA

date: 2025-09-08"
last_modified_at: 2025-09-08"
---

# @Transactional

> @Transactional은 하나의 메서드 또는 클래스 내에서 실행되는 작업을 하나의 트랜잭션 단위로 묶어주는 어노테이션<br>
> 즉, 메서드 안의 모든 작업이 모두 성공하거나, 하나라도 실패하면 전부 롤백되도록 보장함

## 주요 개념

- 트랜잭션(Transaction): 데이터베이스의 하나의 작업 단위, 모두 성공하거나 모두 실패해야함
- 커밋(Commit): 트랜잭션의 작업을 확정/저장
- 롤백(Rollback): 트랜잭션의 작업을 되돌림, 에러 발생 시 주로 실행

## 동작 방식

```java
@Transactional
public void doSomething() {
    repository.save(entity1);  // INSERT
    repository.save(entity2);  // INSERT
    throw new RuntimeException(); // 예외 발생
}
```

- repository가 jparepository구현체기 때문에 save()하나도 기본적으로 transaction단위로 실행됨
- 밑에 예외가 없더라도 entity1, entity2가 db에 저장되기 전까지 트랜잭션이 커밋되지 않음.
- 메소드 전체가 트랜잭션 단위인데 RuntimeException이 발생하므로, 전체 트랜잭션이 롤백되고 DB에는 아무것도 저장되지 않아.

### 선언 위치에 따라

- 클래스에 선언하면 ➡️ 클래스의 모든 public 메서드에 트랜잭션 적용
- 메서드에 선언하면 ➡️ 해당 메서드에 트랜잭션 적용

### 주요 옵션

| 속성                       | 설명                                   | 예시                                                  |
| :------------------------- | :------------------------------------- | :---------------------------------------------------- |
| readOnly = true            | 읽기 전용 쿼리 (쓰기 방지 & 성능 향상) | @Transactional(readOnly = true)                       |
| rollbackFor = 예외.class   | 특정 예외 발생 시 롤백                 | @Transactional(rollbackFor = IOException.class)       |
| noRollbackFor = 예외.class | 특정 예외는 롤백 안 함                 | @Transactional(noRollbackFor = CustomException.class) |
| propagation                | 트랜잭션 전파 방식 설정                | 기본: REQUIRED                                        |

#### 트랜잭션 전파(propagation)

트랜 잭션이 중첩될 떄의 동작을 제어함

- REQUIRED: 기존 트랜잭션으로 있으면 참여, 없으면 새로 시작(기본값)
- REQUIRES_NEW: 무조건 새 트랜잭션 시작
- NESTED: 기존 트랜잭션 안에 중첩 트랜잭션 시작(savepoint생성)

## ⚠️⚠️ @Transactional 주의 사항 ⚠️⚠️

1. 런타임 예외만 롤백됨<br>
   → checked 예외는 기본적으로 롤백 안 됨 (rollbackFor 명시 필요)
2. ✨✨프록시 기반 동작✨✨<br>
   → 같은 클래스 내에서 this.메서드()처럼 호출하면 트랜잭션이 적용되지 않음
3. 트랜잭션 안에서는 지연 로딩 주의<br>
   → Lazy 로딩은 트랜잭션이 종료되면 동작 안 할 수 있음

## AOP

[옛날 포스트](/_posts/springStartHere/2025-04-12-springStartCH6.md)

> AOP(관점 지향 프로그래밍): 핵심 비지니스 로직에 공통기능을 따로 분리해서, 필요한 곳에 자동으로 끼워넣는 기법

- 트랜잭션 처리
- 로깅
- 보안 검사
- 성능 측정 등

많은 메서드에서 반복되지만 로직마다 직접 넣기엔 비효율적이라 AOP로 분리함

### AOP 동작 방식

#### 1. Aspect

- 공통적인 기능(예: 로깅, 트랜잭션 처리 등)을 분리해서 관리하는 모듈.
- @Aspect로 정의됨.

#### 2. Join Point

- 실행 시점(execution point), 예: 메서드 호출, 생성자 호출 등.

#### 3. Pointcut

- 어떤 Join Point에 Advice를 적용할지 결정하는 조건.
- 예: execution(_ com.example.service.._(..)) → 특정 패키지의 모든 메서드

#### 4. Advice

- 실제로 실행되는 부가 기능 로직.
- 종류:
- @Before: 메서드 실행 전
- @After: 메서드 실행 후
- @AfterReturning: 정상 종료 후
- @AfterThrowing: 예외 발생 시
- @Around: 메서드 실행 전후 전체 제어

### 그래서

```
[내가 호출한 비즈니스 로직을 가진 빈의 메서드]
→ [애프펙트 클래스가 실행 흐름을 가로챔]
→ [원하는 기능 수행]
```

AOP 대상이 된 스프링 빈은 실제 구현체가 아닌 프록시 객체로 감싸진다.

아래는 대표적인 로깅애프팩트 예제이다

```java
@Aspect
@Component
public class LoggingAspect {

    @Around("execution(* com.example.service..*(..))")
    public Object logExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        System.out.println("🔵 [시작] " + methodName);

        Object result = joinPoint.proceed(); // 실제 메서드 실행

        System.out.println("✅ [종료] " + methodName);
        return result;
    }
}
```

## JPA의 AOP방식 트랜잭션 처리

```
@PostService.doSomething()
 ↓
[프록시가 가로챔] → @Transactional 확인
 ↓
트랜잭션 시작
 ↓
실제 doSomething 실행
 ↓
성공 → 커밋 / 실패 → 롤백
```

### 어떤 경우에 프록시 객체가 생성되는가?

> 스프링에서 프록시 객체로 wrapping되는 경우는 딱 두가지임

- @Transactional, @Async, @Cacheable 등 AOP 어노테이션 사용 시 <br>
  -> 공통 관심사(cross-cutting concern)가 적용되는 경우

- 커스텀 Aspect 클래스(@Aspect)를 만들어 특정 포인트컷/어드바이스를 지정한 경우<br>
  -> 예: 특정 패키지의 모든 메서드 실행 전에 로그 찍기 등

이외의 객체들은 AOP 대상이 아니면 프록시 없이 원본 객체 자체가 빈으로 등록된다

#### 프록시 객체는 어떻게 생성되는가?

프록시 객체는 '진짜 객체'를 감싸고 대신 행동하는 대리인 객체

```java
MemberService service = new MemberService();
```

위의 service객체에 AOP가 적용되면 아래와 같이

```java
MemberService service = new Proxy(new MemberService());
```

프록시 객체가 진짜 객체를 감싸고, 메서드를 대신 받아서 내부적으로 진짜 객체를 호출하는 구조임!!

### ⚠️⚠️ @Transactional 주의 사항 ⚠️⚠️ 이거 떄문에 AOP내용 깔음

```
[다른 클래스] ---> [프록시 객체] ---> [진짜 객체]
                     ↑
                   (여기서 AOP Advice 실행)
```

- AOP로 애스팩트를 적용하면 프록시 객체를 통해서 동작함

- 프록시 객체는 메서드가 실행되기 전에 필요한 어드바이스(@Before, @Around 등)를 실행하고

- 그 후에 진짜 객체의 메서드를 호출하거나, 조건에 따라 아예 호출하지 않기도 함

- 프록시는 다른 클래스에서 호출할 때만 개입할 수 있음

```java
@Service
public class MyService {

    @Transactional
    public void methodA() {
        methodB(); // ❌ 트랜잭션 적용 안됨 (프록시 안 거침)
    }

    @Transactional
    public void methodB() {
        // ...
    }
}
```

```java
@Service
public class MemberService {

    @Transactional
    public void join() {
        ...
    }

    public void validate() {
        ...
    }
}
```

- 위와 같이 같은 클래스 내부에서 메서드 호출하면 프록시를 거치지 않기 때문에 AOP가 작동하지 않음

- 프록시는 외부 호출만 감지할 수 있다.

#### 내부에서 호출하면 왜 프록시를 우회하게 되냐면

```java
@Service
public class MyService {
    @Transactional
    public void methodA() {
        methodB(); // 내부 호출
    }

    @Transactional
    public void methodB() {
        // DB 작업
    }
}
```

스프링이 실행 시점에 하는 일:

- MyService 클래스가 빈으로 등록되면
- 스프링은 이 클래스의 프록시 객체(MyServiceProxy) 를 만들어서 등록함
- 이 프록시 객체는 트랜잭션 시작/커밋/롤백 등의 논리를 감싸고 있음
- 다른 곳에서 MyService를 의존성 주입받으면 실제 객체가 아니라 프록시 객체가 주입됨

```
SomeController -> [MyService Proxy] -> methodB()
                       ↑ 트랜잭션 감지함!
```

그런데 내부에서 호출하게 되면

```
[MyService Proxy] -> methodA() → this.methodB()
                                 ↑ 그냥 실제 객체 내 호출
```

### 그럼 내부 호출에서도 aop가 동작하려면

방법 1: 우선 다른 클래스로 분리하는 직관적인 방법이 있음

방법 2: 현재 클래스의 프록시를 주입해서 우회 호출

```java
@RequiredArgsConstructor
@Service
public class MemberService {

    private final MemberService self; // 프록시 자기 자신을 주입 (주의 필요)

    @Transactional
    public void join() {
        self.validate(); // 프록시를 거치기 때문에 AOP 작동 O
    }

    @Transactional
    public void validate() {
        ...
    }
}
```

이 방법은 CGLIB프록시 방식이고 순환 참조를 주의해야 한다..
추천되는 방법은 아니고, 그냥 이해를 돕기위한 설명방식이라고 한다.

## @Transactional 구현체를 까보았어

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Reflective
public @interface Transactional {

	/**
	 * Alias for {@link #transactionManager}.
	 * @see #transactionManager
	 */
	@AliasFor("transactionManager")
	String value() default "";

  // ...여러 메소드들이 더있음...
}
```

### 인터페이스처럼 보이는데 어떻게 작동하지

자바의 어노테이션 문법을 따른 인터페이스처럼 생긴 어노테이션 정의이다. 근데 이게 어떻게 동작하는 걸까...

### Runtime Retention

```java
@Retention(RetentionPolicy.RUNTIME)
```

- 이 뜻은 JVM이 런타임에도 이 어노테이션 정보를 유지한다는 뜻이라고 한다.
- 즉, 스프링이 리플렉션(Reflection)으로 클래스, 메서드에 붙은 어노테이션을 읽을 수 있음

### 스프링이 이걸 읽으면

1. 스프링이 애플리케이션 실행 시, @Transactional이 붙은 클래스/메서드를 스캔함
2. 해당 클래스를 프록시 객체로 감쌈

- AOP 프록시 (JDK 동적 프록시 or CGLIB) 생성

3. 메서드를 호출하면, 프록시가 먼저 개입해서 다음을 수행:

- 트랜잭션 시작 (PlatformTransactionManager 사용)
- 실제 메서드 실행 (super.method())
- 예외 여부에 따라 커밋/롤백

### 실제 동작

> @EnableTransactionManagement 이 친구가 실행함<br>
> 그리고 아래와 같은 흐름으로 실행 된다고 한다

```
@EnableTransactionManagement
        ↓
TransactionManagementConfigurationSelector
        ↓
1. AutoProxyRegistrar → AOP 프록시 생성
2. ProxyTransactionManagementConfiguration
        ↳ @Transactional 매칭 Pointcut 생성
        ↳ TransactionInterceptor 등록
        ↓
→ 프록시 객체가 TransactionInterceptor를 Advice로 가짐
→ 메서드 실행 시, 먼저 TransactionInterceptor.invoke() 실행됨!
```

```java
public class TransactionInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // 1. 트랜잭션 시작
        // 2. 대상 메서드 실행
        // 3. 커밋 or 롤백
    }
}
```

위와 같은 TransactionIntercepter라는 클래스가 프록시에 주입되어 얘를 보고 메서드를 가로채게 된다.

### @EnableTransactionManagement 이런건 등록한적이 없는데?

Spring Boot는 내부적으로 @EnableTransactionManagement를 자동으로 등록해줌<br>
→ 그래서 명시적으로 쓴 적 없어도 트랜잭션이 동작했던 거임

> 왜 자동으로 등록되는데?<br>
> 스프링 부트는 자동 설정(Auto Configuration) 기능 덕분에
> 개발자가 자주 사용하는 설정을 미리 등록해줌

### 실제로 gradle에 JPA 의존성을 추가하면

```java
@Configuration
@ConditionalOnClass({ DataSource.class, PlatformTransactionManager.class })
@AutoConfigureAfter({ DataSourceAutoConfiguration.class })
@EnableTransactionManagement // ✅ 여기 붙어 있음
public class DataSourceTransactionManagerAutoConfiguration {
    ...
}
```

Spring Boot의 핵심 자동 설정 클래스 중 하나인 DataSourceTransactionManagerAutoConfiguration 내부에서 등록

<br>

이 클래스가 다음 조건을 만족할 때 자동으로 트랜잭션 매니저 + AOP 설정을 해줌:

- spring-boot-starter-data-jpa 또는 spring-boot-starter-jdbc 의존성이 포함되어 있고

- DataSource 빈이 등록되어 있으면

즉, DataSource와 관련 의존성(JPA, JDBC 등)이 있을 때 자동으로 @EnableTransactionManagement가 스프링 자동설정 클래스에 설정되고, @Transactional이 실행될 수 있도록 한다

## 추가로 공부해볼만한 주제

- JDK / CGLIB 프록시 차이

- [transactionality](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html)

- [transaction management](https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/tx.html)

- [transactionIntercepter](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/TransactionInterceptor.html)
