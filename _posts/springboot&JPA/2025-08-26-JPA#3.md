---
title: "[JPA]SpringBoot&JPA#3"
excerpt: "ApplicationRunner타입"

categories:
  - JPA

date: 2025-08-26 08:00:00 +0900
last_modified_at: 2025-08-26 08:00:00 +0900
---

## ApplicationsRunner 타입 빈 등록

```java
package com.back.global.initData;

import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BaseInitData {

    @Bean
    ApplicationRunner initDataRunner() {
        return args -> {
            System.out.println("초기 데이터를 로딩합니다.");
        };
    }

}
```

- 생김새는 그냥 받아들이면 됨 이렇게 쓰라고 되어있음.
- 스프링부트 애플리케이션이 시작된 직후 실행되는 로직을 정의할 수 있게 해주는 특별한 인터페이스임

## 스프링 빈(Bean)

> 스프링 컨테이너가 생성하고 관리하는 자바 객체

📌 주요 특징

- @Component, @Service, @Repository, @Controller 등의 어노테이션이 붙은 클래스는 자동으로 빈으로 등록
- 빈은 Spring 컨테이너(ApplicationContext)가 생명주기를 관리함
- 싱글톤(singleton)으로 관리되어 애플리케이션 전체에서 하나의 인스턴스를 공유
- 다른 빈에 의존성 주입(DI) 으로 쉽게 연결 가능

### 빈 등록 방법

1. 어노테이션 사용(가장 일반적)

```java
@Component     // 일반 컴포넌트
@Service       // 서비스 계층
@Repository    // DAO, DB 관련 계층
@Controller    // MVC 컨트롤러
@Configuration // 설정 클래스
```

2. 자바 설정 클래스(@Configuration + @Bean)

```java
@Configuration
public class AppConfig {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

3. XML 설정 방식도 있으나 구식 방식임

### 빈 사용 방법(의존성 주입)

1. 생성자 주입 (권장되는 방식)

```java
@Component
public class ServiceA {
    private final MyBean myBean;

    public ServiceA(MyBean myBean) {
        this.myBean = myBean;
    }
}
```

> 생성자가 단 하나만 존재한다면, @Autowired 어노테이션을 생략해도 스프링이 자동 주입 </br>
> 스프링 4.3 이상에서 가능한 기능임. 중복 코드 줄이고, 코드 가독성을 위해 도입되었음.

2. 필드 주입

```java
@Component
public class ServiceB {
    @Autowired
    private MyBean myBean;
}
```

### ApplicationContext

- 모든 빈은 ApplicationContext에 등록되며, context.getBean()으로 직접 꺼낼 수도 있음.
- 테스트 코드에서는 @MockBean이나 @TestConfiguration 등을 사용해 커스터마이징 가능.
- 빈의 스코프(scope)도 조정 가능 (singleton, prototype, request, session, …)

### 빈 스코프, 스프링 빈 생명주기는 추후에 깊게...

## ApplicationRunner 빈

> 스프링 부트 애플리케이션이 완전히 시작된 직후 실행되는 특별한 타입의 빈

📌 주요 특징

- run(ApplicationArguments args) 메서드를 구현하여 실행 로직 작성
- 초기 데이터 세팅, 외부 서비스 연결, 캐시 로딩 등을 할 때 유용
- 여러 개 등록 가능하며, @Order 어노테이션으로 실행 순서 지정 가능
- CommandLineRunner와 유사하지만, ApplicationArguments를 통해 이름 기반 CLI 인자 처리 가능

### ApplicationsRunner 인터페이스 정의

```java
@FunctionalInterface
public interface ApplicationRunner extends Runner {

	/**
	 * Callback used to run the bean.
	 * @param args incoming application arguments
	 * @throws Exception on error
	 */
	void run(ApplicationArguments args) throws Exception;

}
```

- ApplicationsArguments를 통해 이름 기반 파라미터를 받아 더 정교하게 다룰 수 있음
- 용도:

  - 샘플 유저/게시글 삽입 등의 테스트 데이터 초기화
  - 디버깅용 로그 출력, 캐시 초기화 등 로컬 기반 전용 세팅
  - 애플리케이션 구동직후 배치 트리거

- @SpringBootApplication -> main() -> 스프링 컨텍스트 초기화 -> ApplicationRunner.run() 순서로 실행됨
- 서버가 완전히 뜨고 난 후에 동작한다
- 비슷한 기능하는 어노테이션으로 @CommandLineRunner가 있음 -> args를 String배열로만 받아 더 단순한 용도에 적합함

### @Order 사용 예

```java
@Component
@Order(1)
public class RunnerA implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        System.out.println("RunnerA 실행 (Order 1)");
    }
}
```

```java
@Component
@Order(2)
public class RunnerB implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        System.out.println("RunnerB 실행 (Order 2)");
    }
}
```

```console
RunnerA 실행 (Order 1)
RunnerB 실행 (Order 2)
```

- 순서제어는 Bean으로 등록된 경우에만 의미가 있음
- @Order는 ApplicationsRunner, CommandLineRunner 모두 사용 가능
