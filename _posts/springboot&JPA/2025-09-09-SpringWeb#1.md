---
title: "스프링 웹#1"
date: 2025-09-09 09:00:00 +0900
categories: [Spring]
tags: [java, spring, backend]
---
# `<form>`

예시를 위한 코드

```java
@Controller
public class PostController {

    @GetMapping("/posts/write")
    @ResponseBody
    public String write() {

        return """
                <form action="https://localhost:8080/">
                  <input type="text" name="title">
                  <br>
                  <textarea name="content"></textarea>
                  <br>
                  <input type="submit" value="작성">
                </form>
                """;
    }

}
```
### @GetMapping("/posts/write")
- 클라이언트가 GET /posts/write로 요청하면 이 메서드가 실행된다
- 이 경로는 글 작성 폼을 보여주는 페이지임


### @ResponseBody
- 리턴값을 HTTP응답 바디에 그대로 출력하라는 의미
- String으로 HTML코드를 반환하면 브라우저는 그걸 페이지 내용으로 해석.

### `<form>`

- 사용자 입력을 서버로 전송할 수 있는 태그임
- action="..." -> 입력 데이터를 보낼 대상 URL
- 기본 전송 방식은 GET임 POST로도 옵션을 줄 수 있음
  - `<form action="submit_url" method="post">`

[자세한 정리](https://inpa.tistory.com/entry/HTML-%F0%9F%93%9A-%ED%8F%BCForm-%ED%83%9C%EA%B7%B8-%EC%A0%95%EB%A6%AC)

# PostWriteForm객체 생성

```java
@AllArgsConstructor
@Getter
public static class PostWriteForm {

    @NotBlank(message = "제목을 입력해주세요.")
    @Size(min = 2, max = 10, message = "제목은 2글자 이상 10글자 이하로 입력해주세요.")
    private String title;

    @NotBlank(message = "내용을 입력해주세요.")
    @Size(min = 2, max = 100, message = "내용은 2글자 이상 100글자 이하로 입력해주세요.")
    private String content;
}
```

- @NotBlank: null 또는 빈문자열을 허용하지 않음
- @Size(min, max): 문자열의 길이를 제한
- 메시지 커스터마이징: 각 어노테이션에 message 속성으로 에러 메시지 설정할 수 있음
- @Valid또는 @Validated와 함께 사용해야 검증이 실제로 컨트롤러에서 수행된다.


# 컨트롤러 메소드에서 받기

```java
@PostMapping("/posts/doWrite")
@ResponseBody
public String doWrite(
        @Valid PostWriteForm form, BindingResult bindingResult
) {

    if(bindingResult.hasErrors()) {
        FieldError fieldError = bindingResult.getFieldError();
        String fieldName = fieldError.getField();
        String errorMessage = fieldError.getDefaultMessage();

        System.out.println("fieldName : " + fieldName);
        System.out.println("errorMessage : " + errorMessage);

        return getWriteFormHtml(errorMessage, form.title, form.content, fieldName);

    }

    Post post = postService.write(form.title, form.content);

    return "%d번 글이 작성되었습니다.".formatted(post.getId());
}
```
- @Valid는 MVC에서 폼 객체나 DTO의 필드 유효성 검사를 자동으로 수행해준다.

- PostMapping으로 POST받은, 클라이언트가 전송한 `<form>`에 담긴 정보가 PostWriteForm의 title, content에 자동으로 매핑됨.

- 위에 객체 필드에 정의한 어노테이션에 의해 유효성 검사를 수행함

- BindingResult가 에러 정보를 수집해 저장하고, 검사 실패 시에 스프링이 예외를 발생시키지 않고 오류 정보를 담아놓음.

- if문에서 bindingResult에 담긴 에러 정보를 출력함.

## 사용자 경험을 위해 에러메세지를 일관된 순서로

```java
@PostMapping("/posts/doWrite")
@ResponseBody
public String doWrite(
        @Valid PostWriteForm form, BindingResult bindingResult
) {
    if(bindingResult.hasErrors()) {
        // 스트림
        String errorMessages = bindingResult.getFieldErrors()
            .stream()
            .map(field -> field.getField() + "-" + field.getDefaultMessage())
            .map(message -> message.split("-"))
            .map(bits -> """
                    <!-- %s --><li data-error-field-name="%s">%s</li>
                    """.formatted(bits[1], bits[0], bits[2]))
            .sorted()
            .collect(Collectors.joining("\n"));

    return getWriteFormHtml(errorMessages, form.title, form.content);
}

    Post post = postService.write(form.title, form.content);

    return "%d번 글이 작성되었습니다.".formatted(post.getId());
}

```

- 스트림으로 sorted()와 `<br>`태그 처리로 @ResponseBody로 직접 출력함